================================================
File: README.md
================================================
# WebXR Basketball with AR Passthrough & VR Hands

This project is a WebXR-based basketball game that leverages augmented reality (AR) passthrough and virtual reality (VR) hands for an immersive experience. It uses Three.js for rendering and Rapier for physics simulation, allowing users to interact with a virtual basketball and hoop within a real-world environment.

## Today's Features
- **AR Passthrough:** Uses ARButton to enable local-floor AR experiences.
- **VR Hands Integration:** Loads generic hand models for both controllers using GLTFLoader and [webxr-input-profiles](https://github.com/immersive-web/webxr-input-profiles/tree/main).
- **Physics Simulation:** Implements physics with Rapier for realistic ball and hoop interactions.
- **Ball Handling:** Allows ball pickup and throw with real-time (smoothed) velocity tracking.
- **Floor Calibration:** Calibrates floor position using detected surfaces.
- **Room Boundaries:** Creates invisible colliders (with padding) based on detected walls to prevent the ball from leaving the play area.

## Planned Enhancements & Features

### Gameplay Enhancements
- **Shot Clock:**  
  - Add a countdown timer to enforce shot timings, complete with visual and audio cues.
- **Dynamic Hoop Placement:**  
  - When a shot is made, remove the current hoop and spawn a new one at a different, valid location within the room.
- **Enhanced Ball Physics:**  
  - Refine ball physics (e.g., spin, restitution, friction, and continuous collision detection) for more natural behavior.

### Visual & Audio Improvements
- **Improved Graphics:**  
  - Upgrade the hoop model with detailed rim and a dynamic net (using cloth simulation) for enhanced realism.
- **In-World Scoreboard:**  
  - Attach a scoreboard to a wall or the hoop's backboard displaying scores, shot counts, and remaining time.
- **Sound & Haptic Feedback:**  
  - Integrate sound effects (dribbling, swishes, rim bounces) and haptic feedback to enhance immersion.
- **Particle Effects:**  
  - Add visual effects (e.g., confetti, sparks) when a shot is made.
- **Debugging Tools:**  
  - Implement visual debugging (such as collider outlines) to assist in fine-tuning physics and gameplay during development.

### Additional Game Features
- **Game Modes & Leaderboards:**  
  - Introduce varied game modes, power-ups, and online leaderboards to track and compare player performance.
- **User Interface Enhancements:**  
  - Develop start screens, pause menus, and interactive tutorials to improve the overall user experience.
- **Replay & Analytics:**  
  - Capture shot statistics and enable a replay feature for players to review their gameplay.

## Todo
- Fix scoreboard postioning
- Fix code to mangage scoring 
- Add shot clock to score board
- Add game over state and new game state if shot clock is exceeded
- Reconcile state vs event managment code (score board, boundries, hoop placement)
- Generate AI-based graphic assets ([this guide](https://thomassimonini.substack.com/p/generate-3d-assets-for-roblox-using)).
- Implement dynamic basket spawning when a shot is made.
- Integrate sound effects and haptic feedback for immersive interactions.
- Add particle effects and visual feedback on scoring.
- Develop power-up mechanics and varied game modes.
- Implement leaderboards and shot replay analytics.


================================================
File: Architecture.md
================================================
                           +-----------------------+
                           |    Core Engine        |
                           | (Renderer, Scene, XR) |
                           +-----------+-----------+
                                       |
                                       v
                           +-----------------------+
                           |  Resource Loader      |
                           +-----------------------+
                                       |
                                       v
                           +-----------------------+
                           |  Physics Engine       |
                           |  Wrapper (RAPIER)     |
                           +-----------+-----------+
                                       |
                                       v
                           +-----------------------+
                           |   Game State Manager  |
                           +-----------+-----------+
                                       |
            +--------------------------+--------------------------+
            |                         |                          |
            v                         v                          v
   +----------------+       +----------------------+     +------------------+
   | Input Manager  |       |   Gameplay Logic     |     | Visual & Audio   |
   | (Controllers,  |       | (Ball/Hoop, Shot     |     | (Graphics, UI,   |
   |  Events)       |       | Clock, Physics, etc.)|     | Sound/Haptics)   |
   +----------------+       +----------------------+     +------------------+
                                       |
                                       v
                           +-----------------------+
                           | Debug & Analytics     |
                           | (Debug Tools, Replay) |
                           +-----------------------+


================================================
File: LICENSE
================================================
MIT License

Copyright (c) 2025 PythicCoder

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.


================================================
File: index.html
================================================
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>AR Basketball Game with A-Frame 1.7.0 (Quest 3 Passthrough)</title>
    <!-- A-Frame 1.7.0 -->
    <script src="https://aframe.io/releases/1.7.0/aframe.min.js"></script>
    <!-- Modern physics system based on cannon-es -->
    <script src="https://cdn.jsdelivr.net/npm/aframe-physics-system@5.0.0-rc.2/dist/aframe-physics-system.min.js"></script>
    <!-- Super-hands for interaction -->
    <script src="https://cdn.jsdelivr.net/npm/aframe-super-hands@4.0.5/dist/aframe-super-hands.min.js"></script>
    <!-- AR hit-test support -->
    <script src="https://cdn.jsdelivr.net/npm/aframe-ar-hit-test@1.0.2/dist/aframe-ar-hit-test.min.js"></script>

    <style>
      body { margin: 0; overflow: hidden; }
      #ar-button {
        position: absolute;
        bottom: 20px;
        left: 50%;
        transform: translateX(-50%);
        padding: 12px 20px;
        background: #4285f4;
        color: white;
        border: none;
        border-radius: 5px;
        font-size: 16px;
        cursor: pointer;
        z-index: 10;
      }
      #overlay {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
        z-index: 9;
      }
    </style>

    <script>
      // Global game state
      const gameState = {
        score: 0,
        shotTime: 24,
        isHoldingBall: false,
        lastCollisionTime: 0
      };

      // ------------------------------
      // BALL MANAGER COMPONENT
      // ------------------------------
      AFRAME.registerComponent('ball-manager', {
        schema: { radius: { type: 'number', default: 0.12 } },
        init: function () {
          const el = this.el;
          if (!el.getAttribute('geometry')) {
            el.setAttribute('geometry', { primitive: 'sphere', radius: this.data.radius });
          }
          if (!el.getAttribute('material')) {
            el.setAttribute('material', { color: '#ff8c00' });
          }
          if (!el.hasAttribute('dynamic-body')) {
            el.setAttribute('dynamic-body', { mass: 1, restitution: 0.7, friction: 0.7 });
          }
          el.setAttribute('grabbable', '');
        }
      });

      // ------------------------------
      // THROWABLE COMPONENT
      // ------------------------------
      AFRAME.registerComponent('throwable', {
        init: function () {
          const el = this.el;
          el.addEventListener('drag-drop', evt => {
            const worldPos = new THREE.Vector3();
            el.object3D.getWorldPosition(worldPos);
            const sceneEl = document.querySelector('a-scene');
            sceneEl.object3D.add(el.object3D);
            el.setAttribute('position', worldPos);
            el.setAttribute('dynamic-body', { mass: 1, restitution: 0.7, friction: 0.7 });
          });
        }
      });

      // ------------------------------
      // HOOP MANAGER COMPONENT
      // ------------------------------
      AFRAME.registerComponent('hoop-manager', {
        schema: { radius: { type: 'number', default: 0.3 }, height: { type: 'number', default: 1.8 } },
        init: function () {
          const el = this.el;
          el.setAttribute('geometry', {
            primitive: 'torus',
            radius: this.data.radius,
            radiusTubular: 0.02,
            segmentsTubular: 32
          });
          el.setAttribute('material', { color: '#ff8c00' });
          el.object3D.rotation.x = Math.PI / 2;
          el.setAttribute('static-body', {});
          const sensor = document.createElement('a-entity');
          sensor.setAttribute('geometry', { primitive: 'cylinder', radius: this.data.radius * 0.9, height: 0.3 });
          sensor.setAttribute('material', { opacity: 0, transparent: true });
          sensor.setAttribute('static-body', { shape: 'cylinder' });
          sensor.classList.add('hoop-sensor');
          el.appendChild(sensor);
        }
      });

      // ------------------------------
      // SCOREBOARD COMPONENT
      // ------------------------------
      AFRAME.registerComponent('scoreboard', {
        schema: { score: { type: 'int', default: 0 } },
        init: function () {
          this.canvas = document.createElement('canvas');
          this.canvas.width = 256;
          this.canvas.height = 128;
          this.ctx = this.canvas.getContext('2d');
          this.texture = new THREE.CanvasTexture(this.canvas);
          this.updateTexture();
          this.el.setAttribute('geometry', { primitive: 'plane', width: 1.5, height: 0.75 });
          this.el.setAttribute('material', { src: this.texture, transparent: true });
        },
        updateTexture: function () {
          this.ctx.clearRect(0, 0, 256, 128);
          this.ctx.fillStyle = "rgba(0,0,0,0.7)";
          this.ctx.fillRect(0, 0, 256, 128);
          this.ctx.font = "40px Arial";
          this.ctx.fillStyle = "#ffffff";
          this.ctx.fillText("Score: " + this.data.score, 20, 70);
          this.texture.needsUpdate = true;
        },
        increment: function () {
          this.data.score++;
          this.updateTexture();
        }
      });

      // ------------------------------
      // SHOT CLOCK COMPONENT
      // ------------------------------
      AFRAME.registerComponent('shot-clock', {
        schema: { time: { type: 'number', default: 24 } },
        init: function () {
          this.elapsed = 0;
          this.canvas = document.createElement('canvas');
          this.canvas.width = 128;
          this.canvas.height = 128;
          this.ctx = this.canvas.getContext('2d');
          this.texture = new THREE.CanvasTexture(this.canvas);
          this.updateTexture();
          this.el.setAttribute('geometry', { primitive: 'plane', width: 0.6, height: 0.6 });
          this.el.setAttribute('material', { src: this.texture, transparent: true });
        },
        tick: function (time, timeDelta) {
          if (this.data.time > 0) {
            this.data.time -= timeDelta / 1000;
            if (Math.floor(this.data.time * 10) !== Math.floor((this.data.time + timeDelta / 1000) * 10)) {
              this.updateTexture();
            }
          } else {
            console.log("Shot clock expired!");
            this.data.time = 24;
            this.updateTexture();
          }
        },
        updateTexture: function () {
          this.ctx.clearRect(0, 0, 128, 128);
          this.ctx.fillStyle = "rgba(0,0,0,0.7)";
          this.ctx.fillRect(0, 0, 128, 128);
          this.ctx.font = "60px Arial";
          this.ctx.fillStyle = "#ff0000";
          this.ctx.textAlign = "center";
          this.ctx.fillText(Math.ceil(this.data.time), 64, 80);
          this.texture.needsUpdate = true;
        }
      });

      // ------------------------------
      // INPUT MANAGER COMPONENT
      // ------------------------------
      AFRAME.registerComponent('input-manager', {
        init: function () {
          const sceneEl = this.el;
          ['left', 'right'].forEach(hand => {
            const handEl = document.createElement('a-entity');
            handEl.setAttribute('hand-controls', { hand: hand });
            handEl.setAttribute('super-hands', '');
            sceneEl.appendChild(handEl);
          });
        }
      });

      // ------------------------------
      // COLLISION CHECKER COMPONENT
      // ------------------------------
      AFRAME.registerComponent('collision-checker', {
        init: function () {
          this.ball = document.querySelector('#ball');
          this.scoreboardEl = document.querySelector('#scoreboard');
          this.hoopSensor = null;
          this.checkHoopSensor = setInterval(() => {
            this.hoopSensor = document.querySelector('#hoop .hoop-sensor');
            if (this.hoopSensor) {
              clearInterval(this.checkHoopSensor);
              console.log("Hoop sensor found and ready for collision detection");
            }
          }, 500);
        },
        tick: function () {
          if (this.ball && this.hoopSensor) {
            const ballPos = new THREE.Vector3();
            this.ball.object3D.getWorldPosition(ballPos);
            const sensorPos = new THREE.Vector3();
            this.hoopSensor.object3D.getWorldPosition(sensorPos);
            const distance = ballPos.distanceTo(sensorPos);
            if (distance < 0.2 && (performance.now() - gameState.lastCollisionTime > 1000)) {
              console.log("Basket made!");
              gameState.lastCollisionTime = performance.now();
              if (this.scoreboardEl && this.scoreboardEl.components.scoreboard) {
                this.scoreboardEl.components.scoreboard.increment();
              }
            }
          }
        }
      });

      // ------------------------------
      // ROOM MAPPER COMPONENT
      // ------------------------------
      AFRAME.registerComponent('room-mapper', {
        init: function () {
          this.planes = [];
          this.el.addEventListener('ar-hit-test-update', evt => {
            this.planes.forEach(plane => plane.parentNode.removeChild(plane));
            this.planes = [];
            evt.detail.hits.forEach(hit => {
              const plane = document.createElement('a-entity');
              plane.setAttribute('geometry', { primitive: 'plane', width: 1, height: 1 });
              plane.setAttribute('material', { color: '#CCC', opacity: 0.3, side: 'double' });
              const matrix = new THREE.Matrix4();
              matrix.fromArray(hit.transform.matrix);
              const pos = new THREE.Vector3();
              const quat = new THREE.Quaternion();
              const scale = new THREE.Vector3();
              matrix.decompose(pos, quat, scale);
              plane.setAttribute('position', pos);
              plane.object3D.quaternion.copy(quat);
              this.el.appendChild(plane);
              this.planes.push(plane);
            });
          });
        }
      });

      // ------------------------------
      // QUEST PASSTHROUGH SETUP COMPONENT
      // ------------------------------
      AFRAME.registerComponent('quest-passthrough-setup', {
        init: function () {
          const sceneEl = this.el;
          sceneEl.addEventListener('enter-vr', function () {
            if (sceneEl.is('ar-mode')) {
              console.log('Entered AR mode with passthrough');
            }
          });
          sceneEl.addEventListener('xr-session-start-error', function (evt) {
            console.error('Error starting XR session:', evt.detail);
            const message = document.createElement('div');
            message.style.position = 'absolute';
            message.style.top = '50%';
            message.style.left = '50%';
            message.style.transform = 'translate(-50%, -50%)';
            message.style.color = 'white';
            message.style.backgroundColor = 'rgba(0,0,0,0.7)';
            message.style.padding = '20px';
            message.innerHTML = 'Error starting AR: ' + evt.detail.message;
            document.body.appendChild(message);
          });
          this.el.addEventListener('ar-hit-test-select', function (evt) {
            const hoop = document.querySelector('#hoop');
            const ball = document.querySelector('#ball');
            const scoreboard = document.querySelector('#scoreboard');
            const shotclock = document.querySelector('#shotclock');
            if (hoop && ball && scoreboard && shotclock) {
              const hit = evt.detail.hit;
              const matrix = new THREE.Matrix4();
              matrix.fromArray(hit.transform.matrix);
              const pos = new THREE.Vector3();
              const quat = new THREE.Quaternion();
              const scale = new THREE.Vector3();
              matrix.decompose(pos, quat, scale);
              hoop.setAttribute('position', { x: pos.x, y: pos.y + 1.5, z: pos.z });
              ball.setAttribute('position', { x: pos.x + 0.5, y: pos.y + 1, z: pos.z + 0.5 });
              scoreboard.setAttribute('position', { x: pos.x, y: pos.y + 2.5, z: pos.z - 0.3 });
              scoreboard.setAttribute('rotation', { x: 0, y: 0, z: 0 });
              shotclock.setAttribute('position', { x: pos.x + 0.8, y: pos.y + 2.5, z: pos.z - 0.3 });
              shotclock.setAttribute('rotation', { x: 0, y: 0, z: 0 });
              document.querySelectorAll('.hit-test-plane').forEach(plane => {
                plane.setAttribute('visible', false);
              });
              document.getElementById('ar-button').style.display = 'none';
            }
          });
        }
      });
    </script>
  </head>
  <body>
    <!-- DOM Overlay for WebXR -->
    <div id="overlay"></div>
    <!-- AR Entry Button -->
    <button id="ar-button">Enter AR Basketball</button>
    <!-- A-Frame Scene -->
    <a-scene
      webxr="requiredFeatures: local-floor, hit-test, plane-detection, anchors; optionalFeatures: hand-tracking"
      renderer="alpha: true; antialias: true; colorManagement: true; physicallyCorrectLights: true"
      background="transparent: true"
      physics="debug: false"
      ar-hit-test="target:#hoop"
      input-manager
      room-mapper
      collision-checker
      quest-passthrough-setup
      embedded
    >
      <a-entity camera look-controls position="0 1.6 0"></a-entity>
      <a-entity id="ball" ball-manager grabbable throwable position="0 1 -1"></a-entity>
      <a-entity id="hoop" hoop-manager position="0 2 -2"></a-entity>
      <a-entity id="scoreboard" scoreboard position="0 2.5 -2"></a-entity>
      <a-entity id="shotclock" shot-clock position="1 2.5 -2"></a-entity>
    </a-scene>
    <script>
      // Start AR session when the button is clicked
      document.getElementById('ar-button').addEventListener('click', function () {
        const sceneEl = document.querySelector('a-scene');
        if (sceneEl.hasLoaded) {
          sceneEl.enterVR();
        } else {
          sceneEl.addEventListener('loaded', function () {
            sceneEl.enterVR();
          });
        }
      });
    </script>
  </body>
</html>


================================================
File: src/main.js
================================================
// src/main.js
import * as THREE from "three";
import { initEngine, getRenderer, getScene, getCamera } from "./core/engine.js";
import { initPhysics, getWorld, getEventQueue, stepPhysics } from "./core/physics.js";
import { initSceneManager } from "./managers/sceneManager.js";
import { initInputManager, getControllers } from "./managers/inputManager.js";
import { handleSurfaceAdded } from "./managers/surfaceManager.js";
import { state } from "./managers/stateManager.js";
import { registerBallInput, updateBall } from "./gameplay/ballManager.js";
import { RealityAccelerator } from "https://unpkg.com/ratk@0.3.0";
import { ScoreboardManager } from "./gameplay/scoreboardManager.js";
import { isBasket } from "./gameplay/hoopManager.js";

let clockGame, accumulator = 0, fixedTimeStep = 1 / 60;
let ratk;
let scoreboardManager; // Add this line

async function initGame() {
    clockGame = new THREE.Clock();
    await initPhysics();  // Wait for Rapier to initialize
    initSceneManager();
    registerBallInput(state);
    initInputManager(state);
    scoreboardManager = new ScoreboardManager(state); // Add this line

    // Setup RealityAccelerator for plane/mesh detection
    ratk = new RealityAccelerator(getRenderer().xr);
    ratk.onPlaneAdded = (event) => handleSurfaceAdded(event, state);
    ratk.onMeshAdded = (event) => handleSurfaceAdded(event, state);
    getScene().add(ratk.root);
    ratk.root.visible = false;

    // Start the render loop
    getRenderer().setAnimationLoop(animate);
}

function animate() {
    const delta = clockGame.getDelta();
    accumulator += delta;
    while (accumulator >= fixedTimeStep) {
        stepPhysics(); // Use the new stepPhysics function
        const eventQueue = getEventQueue(); // Get the event queue
        
        eventQueue.drainCollisionEvents((event) => {
            console.log("Received collision event", event);
            let collider1 = event.collider1();
            let collider2 = event.collider2();
            debugger;
            if (isBasket(collider1, collider2)) {
                console.log("Basket made!");
                scoreboardManager.incrementScore();
            }
        });
        accumulator -= fixedTimeStep;
    }

    // Update controller velocities
    getControllers().forEach(controller => {
        const currentPos = new THREE.Vector3().setFromMatrixPosition(controller.matrixWorld);
        if (controller.userData.prevPos) {
            const velocity = new THREE.Vector3().subVectors(currentPos, controller.userData.prevPos).divideScalar(delta);
            controller.userData.velocity.copy(velocity);
        }
        controller.userData.prevPos = currentPos.clone();
    });

    // Update RealityAccelerator
    if (ratk && typeof ratk.update === "function") {
        ratk.update();
    }

    // Update ball position based on physics if not held
    if (state.ballCreated && !state.isHoldingBall) {
        updateBall(delta, state.roomBoundary);
    }

    getRenderer().render(getScene(), getCamera());
}

document.getElementById("ar-button").addEventListener("click", async () => {
    try {
        initEngine();
        const session = await navigator.xr.requestSession("immersive-ar", {
            requiredFeatures: ["local-floor", "hit-test", "plane-detection", "anchors"],
            optionalFeatures: ["mesh-detection"],
        });
        getRenderer().xr.setReferenceSpaceType("local-floor");
        getRenderer().xr.setSession(session);
        console.log("AR session started.");
        initGame();
    } catch (err) {
        console.error("Failed to start AR session:", err);
    }
});

================================================
File: src/core/engine.js
================================================
// src/core/engine.js
import * as THREE from "three";

let renderer, scene, camera;

export function initEngine() {
  // Create renderer with transparency (for passthrough)
  renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
  renderer.xr.enabled = true;
  renderer.setPixelRatio(window.devicePixelRatio);
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.setClearColor(0x000000, 0);
  document.body.appendChild(renderer.domElement);

  // Create scene and camera
  scene = new THREE.Scene();
  scene.background = null;
  camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.01, 20);
  camera.position.set(0, 1.6, 0);
  scene.add(camera);

  // Add lighting
  const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 0.6);
  scene.add(hemiLight);
  const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
  dirLight.position.set(0, 4, 2);
  scene.add(dirLight);

  // Resize handler
  window.addEventListener("resize", () => {
    if (!renderer.xr.getSession()) {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }
  });
}

export function getRenderer() {
  return renderer;
}

export function getScene() {
  return scene;
}

export function getCamera() {
  return camera;
}


================================================
File: src/core/eventBus.js
================================================
// Language: JavaScript
export const eventBus = {
    events: {},
    on(event, listener) {
      if (!this.events[event]) {
        this.events[event] = [];
      }
      this.events[event].push(listener);
    },
    off(event, listener) {
      if (!this.events[event]) return;
      this.events[event] = this.events[event].filter(l => l !== listener);
    },
    emit(event, payload) {
      if (this.events[event]) {
        this.events[event].forEach(listener => listener(payload));
      }
    }
  };

================================================
File: src/core/physics.js
================================================
import * as RAPIER from "rapier";

let world;
let eventQueue; // Add this line

export async function initPhysics() {
  await RAPIER.init();
  world = new RAPIER.World({ x: 0, y: -9.8, z: 0 });
  eventQueue = new RAPIER.EventQueue(true); // Add this line
}

export function getWorld() {
  return world;
}

export function getEventQueue() { // Add this function
    return eventQueue;
}

export function stepPhysics() { // Add this function
    world.step(eventQueue);
}

export function createGroundPhysics(floorOffset) {
  const groundBodyDesc = RAPIER.RigidBodyDesc.fixed().setTranslation(0, floorOffset, 0);
  const groundBody = world.createRigidBody(groundBodyDesc);
  const groundColliderDesc = RAPIER.ColliderDesc.cuboid(5, 0.1, 5)
    .setRestitution(0.7)
    .setFriction(0.8);
  world.createCollider(groundColliderDesc, groundBody);
  return groundBody;
}

export function createRoomWalls(roomBoundary) {
  const padding = 0.2;
  const wallThickness = 0.1;
  const halfThickness = wallThickness / 2;
  const centerX = (roomBoundary.min.x + roomBoundary.max.x) / 2;
  const centerY = (roomBoundary.min.y + roomBoundary.max.y) / 2;
  const centerZ = (roomBoundary.min.z + roomBoundary.max.z) / 2;
  const halfWidth = (roomBoundary.max.x - roomBoundary.min.x) / 2;
  const halfHeight = (roomBoundary.max.y - roomBoundary.min.y) / 2;
  const halfDepth = (roomBoundary.max.z - roomBoundary.min.z) / 2;
  
  // Left wall
  {
    const xPos = roomBoundary.min.x - padding;
    const wallBodyDesc = RAPIER.RigidBodyDesc.fixed().setTranslation(xPos, centerY, centerZ);
    const wallBody = world.createRigidBody(wallBodyDesc);
    const wallColliderDesc = RAPIER.ColliderDesc.cuboid(halfThickness, halfHeight, halfDepth);
    world.createCollider(wallColliderDesc, wallBody);
  }
  // Right wall
  {
    const xPos = roomBoundary.max.x + padding;
    const wallBodyDesc = RAPIER.RigidBodyDesc.fixed().setTranslation(xPos, centerY, centerZ);
    const wallBody = world.createRigidBody(wallBodyDesc);
    const wallColliderDesc = RAPIER.ColliderDesc.cuboid(halfThickness, halfHeight, halfDepth);
    world.createCollider(wallColliderDesc, wallBody);
  }
  // Back wall
  {
    const zPos = roomBoundary.min.z - padding;
    const wallBodyDesc = RAPIER.RigidBodyDesc.fixed().setTranslation(centerX, centerY, zPos);
    const wallBody = world.createRigidBody(wallBodyDesc);
    const wallColliderDesc = RAPIER.ColliderDesc.cuboid(halfWidth, halfHeight, halfThickness);
    world.createCollider(wallColliderDesc, wallBody);
  }
  // Front wall
  {
    const zPos = roomBoundary.max.z + padding;
    const wallBodyDesc = RAPIER.RigidBodyDesc.fixed().setTranslation(centerX, centerY, zPos);
    const wallBody = world.createRigidBody(wallBodyDesc);
    const wallColliderDesc = RAPIER.ColliderDesc.cuboid(halfWidth, halfHeight, halfThickness);
    world.createCollider(wallColliderDesc, wallBody);
  }
  console.log("Room boundary walls created with padding:", padding);
}

================================================
File: src/effects/graphics.js
================================================
// src/effects/graphics.js
import { GLTFLoader } from "https://cdn.jsdelivr.net/npm/three@0.146.0/examples/jsm/loaders/GLTFLoader.js";

export function loadHandModel(handedness) {
  return new Promise((resolve, reject) => {
    const loader = new GLTFLoader();
    const url = handedness === "left"
      ? "https://raw.githubusercontent.com/immersive-web/webxr-input-profiles/main/packages/assets/profiles/generic-hand/left.glb"
      : "https://raw.githubusercontent.com/immersive-web/webxr-input-profiles/main/packages/assets/profiles/generic-hand/right.glb";
    loader.load(url, (gltf) => resolve(gltf.scene), undefined, (error) => reject(error));
  });
}


// Additional functions for particle effects or debugging overlays can be added here.


================================================
File: src/gameplay/ballManager.js
================================================
// src/gameplay/ballManager.js
import * as THREE from "three";
import * as RAPIER from "rapier";
import { getScene, getCamera } from "../core/engine.js";
import { getWorld } from "../core/physics.js";
import { addObject } from "../managers/sceneManager.js";
import { state } from "../managers/stateManager.js";

let basketballMesh = null;
let ballRigidBody = null, ballCollider = null;

export function createBallPhysics(pos) {
  const world = getWorld();
  const bodyDesc = RAPIER.RigidBodyDesc.dynamic().setTranslation(pos.x, pos.y, pos.z);
  ballRigidBody = world.createRigidBody(bodyDesc);
  const colliderDesc = RAPIER.ColliderDesc.ball(state.BALL_RADIUS)
    .setRestitution(0.7)
    .setFriction(0.7);
    
  ballCollider = world.createCollider(colliderDesc, ballRigidBody);
}

export function createBallVisual(pos) {
  const geometry = new THREE.SphereGeometry(state.BALL_RADIUS, 32, 32);
  const material = new THREE.MeshStandardMaterial({ color: 0xff8c00 });
  basketballMesh = new THREE.Mesh(geometry, material);
  basketballMesh.position.copy(pos);
  addObject(basketballMesh);
}

export function updateBall(delta, roomBoundary) {
  if (ballRigidBody && basketballMesh) {
    const t = ballRigidBody.translation();
    basketballMesh.position.set(t.x, t.y, t.z);
    const r = ballRigidBody.rotation();
    basketballMesh.quaternion.set(r.x, r.y, r.z, r.w);
    clampBallPosition(roomBoundary);
  }
}

function clampBallPosition(roomBoundary) {
  if (ballRigidBody && roomBoundary) {
    const t = ballRigidBody.translation();
    const clampedX = THREE.MathUtils.clamp(t.x, roomBoundary.min.x + state.BALL_RADIUS, roomBoundary.max.x - state.BALL_RADIUS);
    const clampedZ = THREE.MathUtils.clamp(t.z, roomBoundary.min.z + state.BALL_RADIUS, roomBoundary.max.z - state.BALL_RADIUS);
    if (t.x !== clampedX || t.z !== clampedZ) {
      ballRigidBody.setTranslation({ x: clampedX, y: t.y, z: clampedZ }, true);
      ballRigidBody.setLinvel({ x: 0, y: 0, z: 0 }, true);
    }
  }
}

export function registerBallInput(state) {
  // Register onGrab and onRelease callbacks for controller events
  state.onGrab = onGrab;
  state.onRelease = onRelease;
}

function onGrab(event, controller) {
  if (!basketballMesh) {
    console.warn("No basketballMesh available to grab.");
    return;
  }
  if (!state.isHoldingBall) {
    if (ballRigidBody) {
      getWorld().removeRigidBody(ballRigidBody);
      ballRigidBody = null;
      ballCollider = null;
    }
    if (basketballMesh.parent) {
      basketballMesh.parent.remove(basketballMesh);
    }
    controller.add(basketballMesh);
    if (controller.userData.handedness === "left") {
      basketballMesh.position.set(0.1, 0.0, -0.08);
    } else {
      basketballMesh.position.set(-0.1, 0.0, -0.08);
    }
    state.isHoldingBall = true;
  } else {
    const currentHolder = basketballMesh.parent;
    if (currentHolder !== controller) {
      if (currentHolder) currentHolder.remove(basketballMesh);
      controller.add(basketballMesh);
      if (controller.userData.handedness === "left") {
        basketballMesh.position.set(0.1, 0.0, -0.08);
      } else {
        basketballMesh.position.set(-0.1, 0.0, -0.08);
      }
    }
  }
}

function onRelease(event, controller) {
  if (!basketballMesh) {
    console.warn("No basketballMesh available to release.");
    return;
  }
  if (state.isHoldingBall) {
    state.isHoldingBall = false;
    basketballMesh.updateMatrixWorld();
    const worldPos = new THREE.Vector3();
    basketballMesh.getWorldPosition(worldPos);
    if (basketballMesh.parent) {
      basketballMesh.parent.remove(basketballMesh);
    }
    getScene().add(basketballMesh);
    basketballMesh.position.copy(worldPos);
    createBallPhysics({ x: worldPos.x, y: worldPos.y, z: worldPos.z });
    const throwVelocity = controller.userData.velocity || new THREE.Vector3();
    ballRigidBody.setLinvel({ x: throwVelocity.x, y: throwVelocity.y, z: throwVelocity.z }, true);
  }
}


================================================
File: src/gameplay/hoopManager.js
================================================
import * as THREE from "three";
import * as RAPIER from "rapier";
import { getScene, getCamera } from "../core/engine.js";
import { getWorld } from "../core/physics.js";
import { addObject } from "../managers/sceneManager.js";
import { state } from "../managers/stateManager.js";

let hoopMesh = null;
let backboardMesh = null;
let netMesh = null;
let hoopBody = null, boardBody = null, netBody = null;
let sensor;

export function createHoopPhysics(pos) {
  const world = getWorld();

  // -------------------------
  // Hoop ring physics
  // -------------------------
  const hoopBodyDesc = RAPIER.RigidBodyDesc.fixed().setTranslation(pos.x, pos.y, pos.z);
  hoopBody = world.createRigidBody(hoopBodyDesc);
  const ringColliderDesc = RAPIER.ColliderDesc.cylinder(0.02, state.HOOP_RADIUS)
    .setRestitution(0.5)
    .setFriction(0.8);

  // Determine orientation so the hoop faces the camera
  const dummy = new THREE.Object3D();
  dummy.position.copy(pos);
  dummy.lookAt(getCamera().position);
  const correction = new THREE.Quaternion().setFromEuler(new THREE.Euler(Math.PI / 2, 0, 0));
  const hoopQuat = dummy.quaternion.clone().multiply(correction);
  ringColliderDesc.setRotation({ x: hoopQuat.x, y: hoopQuat.y, z: hoopQuat.z, w: hoopQuat.w });
  world.createCollider(ringColliderDesc, hoopBody);

  // -------------------------
  // Sensor for basket detection
  // -------------------------
  const sensorDesc = RAPIER.ColliderDesc.cylinder(0.15, state.HOOP_RADIUS * 0.9)
    .setSensor(true)
    .setActiveEvents(RAPIER.ActiveEvents.INTERSECTION_EVENTS)
    // Note: Removing setActiveCollisionTypes to avoid physical response.
    .setRotation({ x: hoopQuat.x, y: hoopQuat.y, z: hoopQuat.z, w: hoopQuat.w });

  // Create a separate fixed rigid body for the sensor at the same position.
  const sensorBodyDesc = RAPIER.RigidBodyDesc.fixed().setTranslation(pos.x, pos.y, pos.z);
  const sensorBody = world.createRigidBody(sensorBodyDesc);
  sensor = world.createCollider(sensorDesc, sensorBody);

  // Visual representation of the sensor for debugging.
  const sensorGeometry = new THREE.CylinderGeometry(state.HOOP_RADIUS * 0.9, state.HOOP_RADIUS * 0.9, 0.15 * 2, 32);
  const sensorMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff00, transparent: true, opacity: 0.5 });
  const sensorMesh = new THREE.Mesh(sensorGeometry, sensorMaterial);
  sensorMesh.position.copy(pos);
  sensorMesh.rotation.x = Math.PI / 2; // Align with the hoop
  addObject(sensorMesh);

  // -------------------------
  // Backboard physics
  // -------------------------
  const boardBodyDesc = RAPIER.RigidBodyDesc.fixed().setTranslation(pos.x, pos.y, pos.z - 0.05);
  boardBody = world.createRigidBody(boardBodyDesc);
  const boardColliderDesc = RAPIER.ColliderDesc.cuboid(0.6, 0.4, 0.01)
    .setRestitution(0.3)
    .setFriction(0.8);
  world.createCollider(boardColliderDesc, boardBody);
}

export function createHoopVisual(pos) {
  console.log("Creating hoop at:", pos);

  // Hoop ring visual
  const hoopGeometry = new THREE.TorusGeometry(state.HOOP_RADIUS, 0.02, 16, 100);
  const hoopMaterial = new THREE.MeshStandardMaterial({ color: 0xff8c00 });
  hoopMesh = new THREE.Mesh(hoopGeometry, hoopMaterial);
  hoopMesh.rotation.x = Math.PI / 2;
  hoopMesh.position.copy(pos);
  addObject(hoopMesh);

  // Backboard visual with multiple layers
  const backboardGroup = new THREE.Group();

  // Main white backboard
  const mainBoardGeom = new THREE.PlaneGeometry(0.6, 0.4);
  const mainBoardMat = new THREE.MeshStandardMaterial({ color: 0xffffff, side: THREE.DoubleSide });
  const mainBoardMesh = new THREE.Mesh(mainBoardGeom, mainBoardMat);

  // Red border
  const frameThickness = 0.02;
  const borderMat = new THREE.MeshStandardMaterial({ color: 0xff0000 });

  const topBorderGeom = new THREE.PlaneGeometry(0.6, frameThickness);
  const topBorderMesh = new THREE.Mesh(topBorderGeom, borderMat);
  topBorderMesh.position.set(0, 0.2, 0.001);

  const bottomBorderMesh = topBorderMesh.clone();
  bottomBorderMesh.position.set(0, -0.2, 0.001);

  const sideBorderGeom = new THREE.PlaneGeometry(frameThickness, 0.4);
  const leftBorderMesh = new THREE.Mesh(sideBorderGeom, borderMat);
  leftBorderMesh.position.set(-0.3, 0, 0.001);

  const rightBorderMesh = leftBorderMesh.clone();
  rightBorderMesh.position.set(0.3, 0, 0.001);

  // Shooter's square
  const shooterBoxGeom = new THREE.PlaneGeometry(0.2, 0.15);
  const shooterBoxMesh = new THREE.Mesh(shooterBoxGeom, borderMat);
  shooterBoxMesh.position.set(0, 0, 0.002);

  backboardGroup.add(mainBoardMesh, topBorderMesh, bottomBorderMesh, leftBorderMesh, rightBorderMesh, shooterBoxMesh);
  backboardGroup.position.copy(pos);
  backboardGroup.translateZ(-0.1);
  backboardGroup.translateY(0.1);
  addObject(backboardGroup);
}

export function isBasket(collider1, collider2) {
  return collider1 === sensor || collider2 === sensor;
}


================================================
File: src/gameplay/scoreboardManager.js
================================================
import * as THREE from "three";
import { addObject } from "../managers/sceneManager.js";
import { getCamera } from "../core/engine.js";
import { eventBus } from "../core/eventBus.js";

export class Scoreboard {
    constructor() {
        this.score = 0;
        // Create an offscreen canvas to render text
        this.canvas = document.createElement("canvas");
        this.canvas.width = 256;
        this.canvas.height = 128;
        this.context = this.canvas.getContext("2d");
        this.texture = new THREE.CanvasTexture(this.canvas);
        const material = new THREE.MeshStandardMaterial({ map: this.texture, transparent: true, side: THREE.DoubleSide });
        const geometry = new THREE.PlaneGeometry(1.5, 0.75);
        this.mesh = new THREE.Mesh(geometry, material);
        this.mesh.frustumCulled = false; // Disable frustum culling
        // Adjust scale â€“ tweak as needed
        this.updateTexture();
        addObject(this.mesh);
    }

    updateTexture() {
        this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
        this.context.fillStyle = "rgba(0, 0, 0, 0.7)";
        this.context.fillRect(0, 0, this.canvas.width, this.canvas.height);
        this.context.font = "40px Arial";
        this.context.fillStyle = "#ffffff";
        this.context.fillText(`Score: ${this.score}`, 20, 70);
        this.texture.needsUpdate = true;
    }

    increment() {
        this.score++;
        this.updateTexture();
    }

    // Places the scoreboard on a wall.
    // pos is a THREE.Vector3 and quat a THREE.Quaternion representing the wall's orientation.
    setPosition(pos, quat) {
        this.mesh.position.copy(pos);
        this.mesh.quaternion.copy(quat);
    }
}

export class ScoreboardManager {
    constructor(state) {
        this.state = state;
        this.scoreboard = new Scoreboard();
        eventBus.on("roomBoundaryReady", (roomBoundary) => {
            console.log("Placing scoreboard...");
            this.placeScoreboard(roomBoundary);
        });
    }

    placeScoreboard(roomBoundary) {
        const camPos = getCamera().position;

        let nearestWall = null;
        let minDist = Infinity;
        let pos = new THREE.Vector3();
        let quat = new THREE.Quaternion();

        // Check distances to each wall
        const distMinX = Math.abs(camPos.x - roomBoundary.min.x);
        const distMaxX = Math.abs(camPos.x - roomBoundary.max.x);
        const distMinZ = Math.abs(camPos.z - roomBoundary.min.z);
        const distMaxZ = Math.abs(camPos.z - roomBoundary.max.z);

        if (distMinX < minDist) {
            minDist = distMinX;
            nearestWall = "minX";
            pos.set(roomBoundary.min.x - 0.1, camPos.y + 1.5, camPos.z);
            quat.setFromAxisAngle(new THREE.Vector3(0, 1, 0), Math.PI / 2);
        }
        if (distMaxX < minDist) {
            minDist = distMaxX;
            nearestWall = "maxX";
            pos.set(roomBoundary.max.x + 0.1, camPos.y + 1.5, camPos.z);
            quat.setFromAxisAngle(new THREE.Vector3(0, 1, 0), -Math.PI / 2);
        }
        if (distMinZ < minDist) {
            minDist = distMinZ;
            nearestWall = "minZ";
            pos.set(camPos.x, camPos.y + 1.5, roomBoundary.min.z - 0.1);
            quat.setFromAxisAngle(new THREE.Vector3(0, 1, 0), 0);
        }
        if (distMaxZ < minDist) {
            minDist = distMaxZ;
            nearestWall = "maxZ";
            pos.set(camPos.x, camPos.y + 1.5, roomBoundary.max.z + 0.1);
            quat.setFromAxisAngle(new THREE.Vector3(0, 1, 0), Math.PI);
        }

        if (nearestWall) {
            this.scoreboard.setPosition(pos, quat);
        }
    }

    incrementScore() {
        this.scoreboard.increment();
    }
}

================================================
File: src/gameplay/shotClock.js
================================================
// src/gameplay/shotClock.js
export function initShotClock(state) {
    state.shotTime = 24;
    console.log("Shot clock initialized with", state.shotTime, "seconds.");
  }
  
  export function updateShotClock(delta, state) {
    if (state.shotTime > 0) {
      state.shotTime -= delta;
    } else {
      console.log("Shot clock expired!");
      // Handle shot timeout here.
    }
  }
  

================================================
File: src/managers/inputManager.js
================================================
// src/managers/inputManager.js
import * as THREE from "three";
import { getScene, getRenderer } from "../core/engine.js";
import { loadHandModel } from "../effects/graphics.js";

const controllers = [];

export function initInputManager(state) {
  const gltfLoader = loadHandModel;
  for (let i = 0; i < 2; i++) {
    const controller = getRenderer().xr.getController(i);
    controller.userData.index = i;
    controller.userData.velocity = new THREE.Vector3();
    controller.addEventListener("connected", (event) => {
      controller.userData.handedness = event.data.handedness;
      gltfLoader(controller.userData.handedness)
        .then((handModel) => {
          const handWrapper = new THREE.Group();
          handModel.rotation.set(Math.PI / 2, 0, 0);
          handWrapper.add(handModel);
          controller.add(handWrapper);
        })
        .catch((error) => console.error("Error loading hand model:", error));
    });
    // Forward squeeze events to state callbacks
    controller.addEventListener("squeezestart", (e) => {
      state.onGrab && state.onGrab(e, controller);
    });
    controller.addEventListener("squeezeend", (e) => {
      state.onRelease && state.onRelease(e, controller);
    });
    getScene().add(controller);
    controllers.push(controller);
  }
}

export function getControllers() {
  return controllers;
}


================================================
File: src/managers/sceneManager.js
================================================
// src/managers/sceneManager.js
import { getScene } from "../core/engine.js";

const objects = [];

export function initSceneManager() {
  console.log("Scene Manager initialized.");
}

export function addObject(object) {
  getScene().add(object);
  objects.push(object);
}

export function removeObject(object) {
  getScene().remove(object);
  const idx = objects.indexOf(object);
  if (idx > -1) objects.splice(idx, 1);
}

export function getObjects() {
  return objects;
}


================================================
File: src/managers/stateManager.js
================================================
// src/managers/stateManager.js
export const state = {
    floorOffset: 0,
    floorConfigured: false,
    groundCreated: false,
    ballCreated: false,
    hoopCreated: false,
    wallsCreated: false,
    roomBoundary: null,
    isHoldingBall: false,
    BALL_RADIUS: 0.12,
    HOOP_RADIUS: 0.3,
    HOOP_HEIGHT: 1.8,
    // Callbacks for input events
    onGrab: null,
    onRelease: null
  };
  

================================================
File: src/managers/surfaceManager.js
================================================
// src/managers/surfaceManager.js
import * as THREE from "three";
import { eventBus } from "../core/eventBus.js";
import { createGroundPhysics, createRoomWalls } from "../core/physics.js";
import { createBallPhysics, createBallVisual } from "../gameplay/ballManager.js";
import { createHoopPhysics, createHoopVisual } from "../gameplay/hoopManager.js";
import { getCamera } from "../core/engine.js";

export function handleSurfaceAdded(event, state) {
  const surfaceMesh = event.planeMesh || event.meshMesh;
  if (!surfaceMesh || !event.semanticLabel) return;
  const label = event.semanticLabel.toLowerCase();
  console.log("Surface added:", label);

  // Floor detection
  if (label === "floor" && !state.floorConfigured) {
    const box = new THREE.Box3().setFromObject(surfaceMesh);
    state.floorOffset = box.min.y;
    state.floorConfigured = true;
    console.log("Floor configured at:", state.floorOffset);
    if (!state.groundCreated) {
      createGroundPhysics(state.floorOffset);
      state.groundCreated = true;
    }
  }
  // Wall detection
  if (label === "wall") {
    const wallBox = new THREE.Box3().setFromObject(surfaceMesh);
    if (!state.roomBoundary) {
      state.roomBoundary = wallBox;
    } else {
      state.roomBoundary.union(wallBox);
    }
    console.log("Updated room boundary:", state.roomBoundary);
    // Notify that room boundaries are available.
    eventBus.emit("roomBoundaryReady", state.roomBoundary);
    if (!state.wallsCreated && state.roomBoundary) {
      createRoomWalls(state.roomBoundary);
      state.wallsCreated = true;
    }
  }
  // Create ball and hoop after floor is configured
  if (state.floorConfigured && !state.ballCreated && !state.hoopCreated) {
    // Ball creation relative to the camera
    const camera = getCamera();
    const ballOffset = new THREE.Vector3(0, 0, -1);
    ballOffset.applyQuaternion(camera.quaternion);
    const ballPos = camera.position.clone().add(ballOffset);
    ballPos.y = state.BALL_RADIUS + state.floorOffset;
    if (state.roomBoundary) {
      ballPos.x = THREE.MathUtils.clamp(ballPos.x, state.roomBoundary.min.x + state.BALL_RADIUS, state.roomBoundary.max.x - state.BALL_RADIUS);
      ballPos.z = THREE.MathUtils.clamp(ballPos.z, state.roomBoundary.min.z + state.BALL_RADIUS, state.roomBoundary.max.z - state.BALL_RADIUS);
    }
    createBallPhysics(ballPos);
    createBallVisual(ballPos);
    state.ballCreated = true;
    
    // Hoop creation relative to the camera
    const hoopOffset = new THREE.Vector3(0, 0, -2.5);
    hoopOffset.applyQuaternion(camera.quaternion);
    const hoopPos = camera.position.clone().add(hoopOffset);
    hoopPos.y = state.HOOP_HEIGHT + state.floorOffset;
    if (state.roomBoundary) {
      hoopPos.x = THREE.MathUtils.clamp(hoopPos.x, state.roomBoundary.min.x + state.HOOP_RADIUS, state.roomBoundary.max.x - state.HOOP_RADIUS);
      hoopPos.z = THREE.MathUtils.clamp(hoopPos.z, state.roomBoundary.min.z + state.HOOP_RADIUS, state.roomBoundary.max.z - state.HOOP_RADIUS);
    }
    createHoopPhysics(hoopPos);
    createHoopVisual(hoopPos);
    state.hoopCreated = true;
    console.log("Ball and hoop created relative to the camera within room bounds.");
  }
}


