<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>WebXR Basketball with AR Passthrough & VR Hands</title>
    <script type="importmap">
      {
        "imports": {
          "three": "https://cdn.jsdelivr.net/npm/three@0.146.0/build/three.module.js"
        }
      }
    </script>
    <style>
      body {
        margin: 0;
        overflow: hidden;
      }
      #score {
        position: absolute;
        top: 10px;
        left: 10px;
        font-size: 24px;
        color: white;
        z-index: 2;
      }
      /* Calibration overlay instructs the user to hold the "X" button on the left controller */
      #calibration {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.7);
        color: white;
        font-size: 24px;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        z-index: 3;
      }
      #calibration p {
        margin: 0;
      }
    </style>
  </head>
  <body>
    <div id="score">Score: 0</div>
    <div id="calibration">
      <p>Please stand in a T-pose (arms extended) for calibration.</p>
      <p>
        Hold the left controller's "X" button for 3 seconds to calibrate the
        floor and change the ball's color.
      </p>
    </div>
    <script type="module">
      import * as THREE from "https://cdn.jsdelivr.net/npm/three@0.146.0/build/three.module.js";
      import { ARButton } from "https://cdn.jsdelivr.net/npm/three@0.146.0/examples/jsm/webxr/ARButton.js";
      import { GLTFLoader } from "https://cdn.jsdelivr.net/npm/three@0.146.0/examples/jsm/loaders/GLTFLoader.js";
      import * as RAPIER from "https://cdn.jsdelivr.net/npm/@dimforge/rapier3d-compat@0.14.0/rapier.es.js";

      let scene, camera, renderer, clock;
      let rapierWorld;
      let score = 0;
      const scoreEl = document.getElementById("score");

      // Three.js meshes and physics references
      let basketballMesh, hoopMesh, backboardMesh;
      let ballRigidBody = null, ballCollider = null;
      let hoopBody = null, boardBody = null;

      // Constants
      const BALL_RADIUS = 0.12;
      const HOOP_RADIUS = 0.3;
      const hoopY = 1.8; // Nominal hoop height above floor
      let floorOffset = 0;

      // Ball pickup/throw configuration:
      let isHoldingBall = false;
      // Array for controllers.
      const controllers = [];

      // For controller calibration polling (left-hand only)
      let calibrateTimeout = null;

      async function init() {
        await RAPIER.init();
        rapierWorld = new RAPIER.World({ x: 0, y: -9.8, z: 0 });

        scene = new THREE.Scene();
        camera = new THREE.PerspectiveCamera(
          70,
          window.innerWidth / window.innerHeight,
          0.01,
          20
        );

        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.xr.enabled = true;
        document.body.appendChild(renderer.domElement);

        // Use ARButton for AR passthrough with local-floor reference.
        document.body.appendChild(
          ARButton.createButton(renderer, { requiredFeatures: ["local-floor"] })
        );

        // Lighting:
        const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 0.6);
        scene.add(hemiLight);
        const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
        dirLight.position.set(0, 4, 2);
        scene.add(dirLight);

        // Create ground.
        createGroundPhysics();
        createGroundVisual();

        // Create basketball.
        createBallPhysics({ x: 0, y: BALL_RADIUS + floorOffset, z: -1 });
        createBallVisual({ x: 0, y: BALL_RADIUS + floorOffset, z: -1 });

        // Create hoop & backboard.
        createHoopPhysics({ x: 0, y: hoopY + floorOffset, z: -2 });
        createHoopVisual({ x: 0, y: hoopY + floorOffset, z: -2 });

        // Set up controllers and attach virtual hand models.
        const gltfLoader = new GLTFLoader();
        for (let i = 0; i < 2; i++) {
          // Create controller for input events.
          const controller = renderer.xr.getController(i);
          controller.userData.index = i;
          // Initialize velocity.
          controller.userData.velocity = new THREE.Vector3();

          // When the controller connects, store its handedness and load the generic hand model.
          controller.addEventListener("connected", (event) => {
            controller.userData.handedness = event.data.handedness;
            const url =
              controller.userData.handedness === "left"
                ? "https://raw.githubusercontent.com/immersive-web/webxr-input-profiles/main/packages/assets/profiles/generic-hand/left.glb"
                : "https://raw.githubusercontent.com/immersive-web/webxr-input-profiles/main/packages/assets/profiles/generic-hand/right.glb";
            gltfLoader.load(
              url,
              (gltf) => {
                const handModel = gltf.scene;
                // Adjust scale for proper overlay. You may tweak 0.15 as needed.
                handModel.scale.set(0.15, 0.15, 0.15);
                handModel.position.set(0, 0, 0);
                controller.add(handModel);
              },
              undefined,
              (error) => {
                console.error("Error loading hand model:", error);
              }
            );
          });

          controller.addEventListener("selectstart", onSelectStart);
          controller.addEventListener("selectend", onSelectEnd);
          scene.add(controller);
          controllers.push(controller);
        }

        clock = new THREE.Clock();
        window.addEventListener("resize", onWindowResize, false);

        renderer.setAnimationLoop(animate);
      }

      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      }

      // Calibration function: calibrates floor and changes ball color.
      function calibrateFloor() {
        const refSpace = renderer.xr.getReferenceSpace();
        let measuredY = 0;
        if (refSpace && refSpace.transform && refSpace.transform.position) {
          measuredY = refSpace.transform.position.y;
        }
        const expectedEyeHeight = 1.6;
        let offset;
        if (measuredY < 0.1) {
          console.warn(
            "Measured Y is too low; using expected eye height for calibration."
          );
          offset = expectedEyeHeight;
        } else {
          offset = measuredY;
        }
        // Update the XR reference space.
        const offsetTransform = new XRRigidTransform({ x: 0, y: -offset, z: 0 });
        const newRefSpace = refSpace.getOffsetReferenceSpace(offsetTransform);
        renderer.xr.setReferenceSpace(newRefSpace);
        floorOffset = offset;
        console.log("Calibration complete. Measured Y:", measuredY, "Offset applied:", offset);
        const calibOverlay = document.getElementById("calibration");
        if (calibOverlay) calibOverlay.style.display = "none";
        // Change the basketball color to green (0x00ff00)
        if (basketballMesh && basketballMesh.material) {
          basketballMesh.material.color.set(0x00ff00);
          console.log("Basketball color changed to green.");
        }
      }

      // Ground creation:
      function createGroundPhysics() {
        const groundBodyDesc = RAPIER.RigidBodyDesc.fixed().setTranslation(0, floorOffset, 0);
        const groundBody = rapierWorld.createRigidBody(groundBodyDesc);
        const groundColliderDesc = RAPIER.ColliderDesc.cuboid(5, 0.1, 5)
          .setRestitution(0.2)
          .setFriction(0.8);
        rapierWorld.createCollider(groundColliderDesc, groundBody);
      }

      function createGroundVisual() {
        const groundGeo = new THREE.CircleGeometry(5, 32);
        const groundMat = new THREE.MeshStandardMaterial({
          color: 0x333333,
          side: THREE.DoubleSide,
          transparent: true,
          opacity: 0.2,
        });
        const groundMesh = new THREE.Mesh(groundGeo, groundMat);
        groundMesh.name = "ground";
        groundMesh.rotation.x = -Math.PI / 2;
        groundMesh.position.y = floorOffset;
        scene.add(groundMesh);
      }

      // Basketball creation:
      function createBallPhysics(pos) {
        const bodyDesc = RAPIER.RigidBodyDesc.dynamic().setTranslation(pos.x, pos.y, pos.z);
        ballRigidBody = rapierWorld.createRigidBody(bodyDesc);
        const colliderDesc = RAPIER.ColliderDesc.ball(BALL_RADIUS)
          .setRestitution(0.7)
          .setFriction(0.7);
        ballCollider = rapierWorld.createCollider(colliderDesc, ballRigidBody);
      }

      function createBallVisual(pos) {
        const geometry = new THREE.SphereGeometry(BALL_RADIUS, 32, 32);
        // Initially set ball color to orange.
        const material = new THREE.MeshStandardMaterial({ color: 0xff8c00 });
        basketballMesh = new THREE.Mesh(geometry, material);
        basketballMesh.position.set(pos.x, pos.y, pos.z);
        basketballMesh.name = "basketball";
        scene.add(basketballMesh);
      }

      // Hoop & backboard creation:
      function createHoopPhysics(pos) {
        const hoopBodyDesc = RAPIER.RigidBodyDesc.fixed().setTranslation(pos.x, pos.y, pos.z);
        hoopBody = rapierWorld.createRigidBody(hoopBodyDesc);

        const ringColliderDesc = RAPIER.ColliderDesc.cylinder(0.02, HOOP_RADIUS)
          .setRestitution(0.5)
          .setFriction(0.8);
        const euler = new THREE.Euler(Math.PI / 2, 0, 0);
        const threeQuat = new THREE.Quaternion().setFromEuler(euler);
        const rapierQuat = { x: threeQuat.x, y: threeQuat.y, z: threeQuat.z, w: threeQuat.w };
        ringColliderDesc.setRotation(rapierQuat);
        rapierWorld.createCollider(ringColliderDesc, hoopBody);

        const boardBodyDesc = RAPIER.RigidBodyDesc.fixed().setTranslation(pos.x, pos.y, pos.z - 0.05);
        boardBody = rapierWorld.createRigidBody(boardBodyDesc);
        const boardColliderDesc = RAPIER.ColliderDesc.cuboid(0.3, 0.2, 0.01)
          .setRestitution(0.3)
          .setFriction(0.8);
        rapierWorld.createCollider(boardColliderDesc, boardBody);
      }

      function createHoopVisual(pos) {
        const hoopGeometry = new THREE.TorusGeometry(HOOP_RADIUS, 0.02, 16, 100);
        const hoopMaterial = new THREE.MeshStandardMaterial({ color: 0xff0000 });
        hoopMesh = new THREE.Mesh(hoopGeometry, hoopMaterial);
        hoopMesh.rotation.x = Math.PI / 2;
        hoopMesh.position.set(pos.x, pos.y, pos.z);
        hoopMesh.name = "hoop";
        scene.add(hoopMesh);

        const boardGeometry = new THREE.PlaneGeometry(0.6, 0.4);
        const boardMaterial = new THREE.MeshStandardMaterial({ color: 0x0000ff });
        backboardMesh = new THREE.Mesh(boardGeometry, boardMaterial);
        backboardMesh.position.set(pos.x, pos.y, pos.z - 0.05);
        scene.add(backboardMesh);
      }

      // Controller event handlers for picking up the ball.
      function onSelectStart(event) {
        const controller = event.target;
        // Snap the ball to the controller regardless of its current location.
        if (!isHoldingBall) {
          if (ballRigidBody) {
            rapierWorld.removeRigidBody(ballRigidBody);
            ballRigidBody = null;
            ballCollider = null;
          }
          scene.remove(basketballMesh);
          controller.add(basketballMesh);
          // Adjust the ball's position relative to the controller so it feels natural.
          basketballMesh.position.set(0, -0.02, -0.1);
          isHoldingBall = true;
        } else {
          // Transfer the ball if held by a different controller.
          const currentHolder = basketballMesh.parent;
          if (currentHolder !== controller) {
            currentHolder.remove(basketballMesh);
            controller.add(basketballMesh);
            basketballMesh.position.set(0, -0.02, -0.1);
          }
        }
      }

      function onSelectEnd(event) {
        const controller = event.target;
        if (isHoldingBall) {
          isHoldingBall = false;
          // Detach the ball from the controller and place it in the world.
          basketballMesh.updateMatrixWorld();
          const worldPos = new THREE.Vector3();
          basketballMesh.getWorldPosition(worldPos);
          controller.remove(basketballMesh);
          basketballMesh.position.copy(worldPos);
          scene.add(basketballMesh);
          createBallPhysics({ x: worldPos.x, y: worldPos.y, z: worldPos.z });
          const throwVelocity = controller.userData.velocity || new THREE.Vector3();
          ballRigidBody.setLinvel(
            { x: throwVelocity.x, y: throwVelocity.y, z: throwVelocity.z },
            true
          );
        }
      }

      // Poll the XR session each frame for the left controller's "X" button.
      function checkControllerXButton() {
        const session = renderer.xr.getSession();
        if (session) {
          session.inputSources.forEach((source) => {
            if (source.handedness === "left" && source.gamepad) {
              const xButton = source.gamepad.buttons[4];
              if (xButton) {
                if (xButton.pressed) {
                  if (!calibrateTimeout) {
                    calibrateTimeout = setTimeout(() => {
                      calibrateFloor();
                      calibrateTimeout = null;
                    }, 3000);
                  }
                } else {
                  if (calibrateTimeout) {
                    clearTimeout(calibrateTimeout);
                    calibrateTimeout = null;
                  }
                }
              } else {
                console.warn("No button at index 4 found on this controller.");
              }
            }
          });
        }
      }

      // Animation loop.
      function animate() {
        const delta = clock.getDelta();

        // Update each controller's velocity.
        controllers.forEach((ctrl) => {
          const currentPos = new THREE.Vector3();
          ctrl.getWorldPosition(currentPos);
          if (!ctrl.userData.prevPos) {
            ctrl.userData.prevPos = currentPos.clone();
          }
          const velocity = currentPos.clone().sub(ctrl.userData.prevPos).divideScalar(delta);
          ctrl.userData.velocity.copy(velocity);
          ctrl.userData.prevPos.copy(currentPos);
        });

        checkControllerXButton();

        // Step physics and update ball mesh if not held.
        if (!isHoldingBall && ballRigidBody && basketballMesh) {
          rapierWorld.step();
          const t = ballRigidBody.translation();
          basketballMesh.position.set(t.x, t.y, t.z);
          const r = ballRigidBody.rotation();
          basketballMesh.quaternion.set(r.x, r.y, r.z, r.w);

          // Check if the ball goes through the hoop.
          if (basketballMesh.position.y < hoopY + floorOffset) {
            const hoopCenter = new THREE.Vector3(0, hoopY + floorOffset, -2);
            if (basketballMesh.position.distanceTo(hoopCenter) < HOOP_RADIUS) {
              score++;
              scoreEl.innerHTML = "Score: " + score;
              rapierWorld.removeRigidBody(ballRigidBody);
              scene.remove(basketballMesh);
              createBallPhysics({ x: 0, y: BALL_RADIUS + floorOffset, z: -1 });
              createBallVisual({ x: 0, y: BALL_RADIUS + floorOffset, z: -1 });
            }
          }
        }

        renderer.render(scene, camera);
      }

      init();
    </script>
  </body>
</html>
