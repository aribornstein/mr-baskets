<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>AR Basketball Game with A-Frame 1.7.0 (Passthrough)</title>
    <!-- Include A-Frame 1.7.0 and the physics system (using Cannon.js) -->
    <script src="https://aframe.io/releases/1.7.0/aframe.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/aframe-physics-system@4.0.1/dist/aframe-physics-system.min.js"></script>
    <style>
      body { margin: 0; overflow: hidden; }
    </style>
    <script>
      // Global game state (extend as needed)
      const gameState = {
        score: 0,
        shotTime: 24,
        isHoldingBall: false,
        lastCollisionTime: 0
      };

      // ===============================
      // BALL MANAGER COMPONENT
      // ===============================
      AFRAME.registerComponent('ball-manager', {
        schema: { radius: { type: 'number', default: 0.12 } },
        init: function () {
          const el = this.el;
          // Set up sphere geometry and material if not preset
          if (!el.getAttribute('geometry')) {
            el.setAttribute('geometry', { primitive: 'sphere', radius: this.data.radius });
          }
          if (!el.getAttribute('material')) {
            el.setAttribute('material', { color: '#ff8c00' });
          }
          // Add dynamic physics properties
          if (!el.hasAttribute('dynamic-body')) {
            el.setAttribute('dynamic-body', { mass: 1, restitution: 0.7, friction: 0.7 });
          }
        }
      });

      // ===============================
      // HOOP MANAGER COMPONENT
      // ===============================
      AFRAME.registerComponent('hoop-manager', {
        schema: { radius: { type: 'number', default: 0.3 }, height: { type: 'number', default: 1.8 } },
        init: function () {
          const el = this.el;
          // Create a hoop ring using a torus geometry
          el.setAttribute('geometry', {
            primitive: 'torus',
            radius: this.data.radius,
            radiusTubular: 0.02,
            segmentsTubular: 32
          });
          el.setAttribute('material', { color: '#ff8c00' });
          // Rotate so the hoop lies horizontally
          el.object3D.rotation.x = Math.PI / 2;
          // Make it a static physics body
          el.setAttribute('static-body', {});
          // Create a child sensor (invisible) for collision detection
          const sensor = document.createElement('a-entity');
          sensor.setAttribute('geometry', { primitive: 'cylinder', radius: this.data.radius * 0.9, height: 0.3 });
          sensor.setAttribute('material', { opacity: 0.0, transparent: true });
          sensor.setAttribute('static-body', { shape: 'cylinder' });
          sensor.setAttribute('class', 'hoop-sensor');
          el.appendChild(sensor);
        }
      });

      // ===============================
      // SCOREBOARD COMPONENT
      // ===============================
      AFRAME.registerComponent('scoreboard', {
        schema: { score: { type: 'int', default: 0 } },
        init: function () {
          // Create an offscreen canvas for the scoreboard
          this.canvas = document.createElement('canvas');
          this.canvas.width = 256;
          this.canvas.height = 128;
          this.ctx = this.canvas.getContext('2d');
          this.texture = new THREE.CanvasTexture(this.canvas);
          this.updateTexture();
          // Create a plane to display the scoreboard
          this.el.setAttribute('geometry', { primitive: 'plane', width: 1.5, height: 0.75 });
          this.el.setAttribute('material', { src: this.texture, transparent: true });
        },
        updateTexture: function () {
          this.ctx.clearRect(0, 0, 256, 128);
          this.ctx.fillStyle = "rgba(0,0,0,0.7)";
          this.ctx.fillRect(0, 0, 256, 128);
          this.ctx.font = "40px Arial";
          this.ctx.fillStyle = "#ffffff";
          this.ctx.fillText("Score: " + this.data.score, 20, 70);
          this.texture.needsUpdate = true;
        },
        increment: function () {
          this.data.score++;
          this.updateTexture();
        }
      });

      // ===============================
      // SHOT CLOCK COMPONENT
      // ===============================
      AFRAME.registerComponent('shot-clock', {
        schema: { time: { type: 'number', default: 24 } },
        init: function () {
          this.elapsed = 0;
        },
        tick: function (time, timeDelta) {
          if (this.data.time > 0) {
            this.data.time -= timeDelta / 1000;
          } else {
            console.log("Shot clock expired!");
            // Handle shot timeout: reset ball position, update state, etc.
            this.data.time = 24; // Reset for demo purposes.
          }
        }
      });

      // ===============================
      // INPUT MANAGER COMPONENT
      // ===============================
      AFRAME.registerComponent('input-manager', {
        init: function () {
          const sceneEl = this.el;
          // Create two hand controllers using A-Frame's hand-controls.
          ['left', 'right'].forEach(hand => {
            const handEl = document.createElement('a-entity');
            handEl.setAttribute('hand-controls', { hand: hand });
            // Listen for squeeze events to trigger grab and release on the ball.
            handEl.addEventListener('squeezestart', evt => {
              const ball = document.querySelector('#ball');
              if (ball && !gameState.isHoldingBall) {
                ball.emit('grab', { controller: handEl });
                gameState.isHoldingBall = true;
              }
            });
            handEl.addEventListener('squeezeend', evt => {
              const ball = document.querySelector('#ball');
              if (ball && gameState.isHoldingBall) {
                ball.emit('release', { controller: handEl });
                gameState.isHoldingBall = false;
              }
            });
            sceneEl.appendChild(handEl);
          });
        }
      });

      // ===============================
      // GRAB/RELEASE BEHAVIOR FOR THE BALL
      // ===============================
      AFRAME.registerComponent('grab-release', {
        init: function () {
          const el = this.el;
          el.addEventListener('grab', evt => {
            // Remove the ballâ€™s physics and attach it to the controller.
            el.removeAttribute('dynamic-body');
            const controller = evt.detail.controller;
            controller.object3D.add(el.object3D);
            // Set a relative offset based on handedness.
            const handData = controller.getAttribute('hand-controls');
            if (handData && handData.hand === 'left') {
              el.setAttribute('position', { x: 0.1, y: 0, z: -0.08 });
            } else {
              el.setAttribute('position', { x: -0.1, y: 0, z: -0.08 });
            }
          });
          el.addEventListener('release', evt => {
            // Detach the ball from the controller and reapply physics.
            const worldPos = new THREE.Vector3();
            el.object3D.getWorldPosition(worldPos);
            const sceneEl = document.querySelector('a-scene');
            sceneEl.object3D.add(el.object3D); // reparent to scene
            el.setAttribute('position', worldPos);
            el.setAttribute('dynamic-body', { mass: 1, restitution: 0.7, friction: 0.7 });
            // Optionally: apply throw velocity based on controller movement.
          });
        }
      });

      // ===============================
      // COLLISION CHECKER FOR SCORING
      // ===============================
      AFRAME.registerComponent('collision-checker', {
        init: function () {
          this.ball = document.querySelector('#ball');
          this.hoopSensor = document.querySelector('.hoop-sensor');
          this.scoreboardEl = document.querySelector('#scoreboard');
        },
        tick: function () {
          if (this.ball && this.hoopSensor) {
            const ballPos = new THREE.Vector3();
            this.ball.object3D.getWorldPosition(ballPos);
            const sensorPos = new THREE.Vector3();
            this.hoopSensor.object3D.getWorldPosition(sensorPos);
            const distance = ballPos.distanceTo(sensorPos);
            // If the ball is close enough to the sensor (and prevent rapid re-triggering)
            if (distance < 0.2 && (performance.now() - gameState.lastCollisionTime > 1000)) {
              console.log("Basket made!");
              gameState.lastCollisionTime = performance.now();
              if (this.scoreboardEl && this.scoreboardEl.components.scoreboard) {
                this.scoreboardEl.components.scoreboard.increment();
              }
            }
          }
        }
      });

      // ===============================
      // SURFACE MANAGER COMPONENT (FLOOR & WALLS)
      // ===============================
      AFRAME.registerComponent('surface-manager', {
        init: function () {
          const sceneEl = this.el;
          // Create a floor entity
          const floor = document.createElement('a-entity');
          floor.setAttribute('geometry', { primitive: 'plane', width: 10, height: 10 });
          floor.setAttribute('material', { color: '#888', opacity: 0.5 });
          floor.setAttribute('rotation', '-90 0 0');
          floor.setAttribute('static-body', {});
          sceneEl.appendChild(floor);
          // Create invisible walls (room boundaries)
          const walls = [
            { pos: { x: 5, y: 2, z: 0 }, rot: { x: 0, y: -90, z: 0 } },
            { pos: { x: -5, y: 2, z: 0 }, rot: { x: 0, y: 90, z: 0 } },
            { pos: { x: 0, y: 2, z: 5 }, rot: { x: 0, y: 180, z: 0 } },
            { pos: { x: 0, y: 2, z: -5 }, rot: { x: 0, y: 0, z: 0 } },
          ];
          walls.forEach(w => {
            const wall = document.createElement('a-entity');
            wall.setAttribute('geometry', { primitive: 'box', width: 0.1, height: 4, depth: 10 });
            wall.setAttribute('material', { opacity: 0, transparent: true });
            wall.setAttribute('position', w.pos);
            wall.setAttribute('rotation', w.rot);
            wall.setAttribute('static-body', {});
            sceneEl.appendChild(wall);
          });
        }
      });
    </script>
  </head>
  <body>
    <!-- The A-Frame scene with passthrough: 
         The renderer is set to use alpha transparency and no background color,
         so that in immersive-ar mode the camera feed (your room) is visible.
    -->
    <a-scene
      physics="debug: false"
      input-manager
      surface-manager
      collision-checker
      embedded
      xr-mode="immersive-ar"
      renderer="alpha: true; antialias: true; premultipliedAlpha: false"
      background="color: #000000; opacity: 0"
    >
      <!-- Camera with look-controls -->
      <a-entity camera look-controls position="0 1.6 0"></a-entity>
      <!-- Ball entity with ball-manager and grab-release behavior -->
      <a-entity id="ball" ball-manager grab-release position="0 1 -1"></a-entity>
      <!-- Hoop entity with hoop-manager -->
      <a-entity id="hoop" hoop-manager position="0 2 -2"></a-entity>
      <!-- Scoreboard entity -->
      <a-entity id="scoreboard" scoreboard position="0 2 -3"></a-entity>
      <!-- Optional Shot Clock display -->
      <a-entity id="shotclock" shot-clock position="1 2 -3"></a-entity>
    </a-scene>
  </body>
</html>
