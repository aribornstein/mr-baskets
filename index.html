<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>WebXR Basketball Game with Delayed Ball/Hoop Init</title>
    <script type="importmap">
      {
        "imports": {
          "three": "https://cdn.jsdelivr.net/npm/three@0.146.0/build/three.module.js"
        }
      }
    </script>
    <style>
      body { margin: 0; overflow: hidden; background: none; }
      canvas { display: block; background: none; }
      #ar-button {
        position: absolute;
        bottom: 20px;
        left: 50%;
        transform: translateX(-50%);
        padding: 12px 24px;
        font-size: 16px;
        z-index: 100;
      }
    </style>
  </head>
  <body>
    <button id="ar-button">Enter AR</button>
    <script type="module">
      import * as THREE from "three";
      import { GLTFLoader } from "https://cdn.jsdelivr.net/npm/three@0.146.0/examples/jsm/loaders/GLTFLoader.js";
      import * as RAPIER from "https://cdn.jsdelivr.net/npm/@dimforge/rapier3d-compat@0.14.0/rapier.es.js";
      import { RealityAccelerator } from "https://unpkg.com/ratk@0.3.0";

      // Global variables for scene and game logic:
      let scene, camera, renderer, clock;
      let rapierWorld;
      let basketballMesh, hoopMesh, backboardMesh;
      let ballRigidBody = null, ballCollider = null;
      let hoopBody = null, boardBody = null;
      let groundMesh;
      let ratk;
      let floorConfigured = false; // becomes true when a floor plane is detected
      let groundCreated = false;   // ensure ground is created only once
      let ballAndHoopCreated = false; // flag to delay ball/hoop init
      let closestWallMesh = null, minWallDistance = Infinity;
      let floorOffset = 0;
      let isHoldingBall = false;
      const controllers = [];
      const BALL_RADIUS = 0.12, HOOP_RADIUS = 0.3, HOOP_HEIGHT = 1.8;

      // Create renderer with transparent settings for passthrough:
      renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
      renderer.xr.enabled = true;
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setClearColor(0x000000, 0);
      document.body.appendChild(renderer.domElement);

      // Create scene and camera:
      scene = new THREE.Scene();
      scene.background = null;
      camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.01, 20);
      camera.position.set(0, 1.6, 0);
      scene.add(camera);

      // Global lighting:
      const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 0.6);
      scene.add(hemiLight);
      const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
      dirLight.position.set(0, 4, 2);
      scene.add(dirLight);

      // Handle window resize (only if XR session is not active):
      window.addEventListener("resize", () => {
        if (!renderer.xr.getSession()) {
          camera.aspect = window.innerWidth / window.innerHeight;
          camera.updateProjectionMatrix();
          renderer.setSize(window.innerWidth, window.innerHeight);
        }
      });

      // ---- Game Logic Functions ----

      function createGroundPhysics() {
        const groundBodyDesc = RAPIER.RigidBodyDesc.fixed().setTranslation(0, floorOffset, 0);
        const groundBody = rapierWorld.createRigidBody(groundBodyDesc);
        const groundColliderDesc = RAPIER.ColliderDesc.cuboid(5, 0.1, 5)
          .setRestitution(0.2)
          .setFriction(0.8);
        rapierWorld.createCollider(groundColliderDesc, groundBody);
      }
      function createGroundVisual() {
        const groundGeo = new THREE.CircleGeometry(5, 32);
        const groundMat = new THREE.MeshStandardMaterial({
          color: 0x333333,
          side: THREE.DoubleSide,
          transparent: true,
          opacity: 0.2,
        });
        groundMesh = new THREE.Mesh(groundGeo, groundMat);
        groundMesh.rotation.x = -Math.PI / 2;
        groundMesh.position.y = floorOffset;
        scene.add(groundMesh);
      }
      function createBallPhysics(pos) {
        const bodyDesc = RAPIER.RigidBodyDesc.dynamic().setTranslation(pos.x, pos.y, pos.z);
        ballRigidBody = rapierWorld.createRigidBody(bodyDesc);
        const colliderDesc = RAPIER.ColliderDesc.ball(BALL_RADIUS)
          .setRestitution(0.7)
          .setFriction(0.7);
        ballCollider = rapierWorld.createCollider(colliderDesc, ballRigidBody);
      }
      function createBallVisual(pos) {
        const geometry = new THREE.SphereGeometry(BALL_RADIUS, 32, 32);
        const material = new THREE.MeshStandardMaterial({ color: 0xff8c00 });
        basketballMesh = new THREE.Mesh(geometry, material);
        basketballMesh.position.set(pos.x, pos.y, pos.z);
        scene.add(basketballMesh);
      }
      function createHoopPhysics(pos) {
        const hoopBodyDesc = RAPIER.RigidBodyDesc.fixed().setTranslation(pos.x, pos.y, pos.z);
        hoopBody = rapierWorld.createRigidBody(hoopBodyDesc);
        const ringColliderDesc = RAPIER.ColliderDesc.cylinder(0.02, HOOP_RADIUS)
          .setRestitution(0.5)
          .setFriction(0.8);
        const euler = new THREE.Euler(Math.PI / 2, 0, 0);
        const threeQuat = new THREE.Quaternion().setFromEuler(euler);
        const rapierQuat = { x: threeQuat.x, y: threeQuat.y, z: threeQuat.z, w: threeQuat.w };
        ringColliderDesc.setRotation(rapierQuat);
        rapierWorld.createCollider(ringColliderDesc, hoopBody);
        const boardBodyDesc = RAPIER.RigidBodyDesc.fixed().setTranslation(pos.x, pos.y, pos.z - 0.05);
        boardBody = rapierWorld.createRigidBody(boardBodyDesc);
        const boardColliderDesc = RAPIER.ColliderDesc.cuboid(0.3, 0.2, 0.01)
          .setRestitution(0.3)
          .setFriction(0.8);
        rapierWorld.createCollider(boardColliderDesc, boardBody);
      }
      function createHoopVisual(pos) {
        const hoopGeometry = new THREE.TorusGeometry(HOOP_RADIUS, 0.02, 16, 100);
        const hoopMaterial = new THREE.MeshStandardMaterial({ color: 0xff0000 });
        hoopMesh = new THREE.Mesh(hoopGeometry, hoopMaterial);
        hoopMesh.rotation.x = Math.PI / 2;
        hoopMesh.position.set(pos.x, pos.y, pos.z);
        scene.add(hoopMesh);
        const boardGeometry = new THREE.PlaneGeometry(0.6, 0.4);
        const boardMaterial = new THREE.MeshStandardMaterial({ color: 0x0000ff });
        backboardMesh = new THREE.Mesh(boardGeometry, boardMaterial);
        backboardMesh.position.set(pos.x, pos.y, pos.z - 0.05);
        scene.add(backboardMesh);
      }
      function onGrab(event) {
        const controller = event.target;
        if (!isHoldingBall) {
          if (ballRigidBody) {
            rapierWorld.removeRigidBody(ballRigidBody);
            ballRigidBody = null;
            ballCollider = null;
          }
          scene.remove(basketballMesh);
          controller.add(basketballMesh);
          basketballMesh.position.set(0, -0.1, -0.15);
          isHoldingBall = true;
        } else {
          const currentHolder = basketballMesh.parent;
          if (currentHolder !== controller) {
            currentHolder.remove(basketballMesh);
            controller.add(basketballMesh);
            basketballMesh.position.set(0, -0.1, -0.15);
          }
        }
      }
      function onRelease(event) {
        const controller = event.target;
        if (isHoldingBall) {
          isHoldingBall = false;
          basketballMesh.updateMatrixWorld();
          const worldPos = new THREE.Vector3();
          basketballMesh.getWorldPosition(worldPos);
          controller.remove(basketballMesh);
          basketballMesh.position.copy(worldPos);
          scene.add(basketballMesh);
          createBallPhysics({ x: worldPos.x, y: worldPos.y, z: worldPos.z });
          const throwVelocity = controller.userData.velocity || new THREE.Vector3();
          ballRigidBody.setLinvel({ x: throwVelocity.x, y: throwVelocity.y, z: throwVelocity.z }, true);
        }
      }

      // Fixed timestep physics:
      const fixedTimeStep = 1 / 60;
      let accumulator = 0;
      const clockGame = new THREE.Clock();
      function animate() {
        const delta = clockGame.getDelta();
        accumulator += delta;
        while (accumulator >= fixedTimeStep) {
          rapierWorld.step();
          accumulator -= fixedTimeStep;
        }
        if (!isHoldingBall && ballRigidBody && basketballMesh) {
          const t = ballRigidBody.translation();
          basketballMesh.position.set(t.x, t.y, t.z);
          const r = ballRigidBody.rotation();
          basketballMesh.quaternion.set(r.x, r.y, r.z, r.w);
        }
        renderer.render(scene, camera);
      }

      // Initialize AR game logic.
      async function initGame() {
        clock = new THREE.Clock();
        await RAPIER.init();
        rapierWorld = new RAPIER.World({ x: 0, y: -9.8, z: 0 });

        // Setup RealityAccelerator for plane detection.
        ratk = new RealityAccelerator(renderer.xr);
        scene.add(ratk.root);
        ratk.onPlaneAdded = (plane) => {
          if (plane.semanticLabel && plane.planeMesh) {
            const label = plane.semanticLabel.toLowerCase();
            if (label === "floor" && !floorConfigured) {
              const box = new THREE.Box3().setFromObject(plane.planeMesh);
              floorOffset = box.min.y;
              floorConfigured = true;
              console.log("Floor configured at:", floorOffset);
              if (!groundCreated) {
                createGroundPhysics();
                createGroundVisual();
                groundCreated = true;
              }
            }
            if (label === "wall") {
              const wallPos = new THREE.Vector3();
              plane.planeMesh.getWorldPosition(wallPos);
              const distance = wallPos.distanceTo(camera.position);
              if (distance < minWallDistance) {
                minWallDistance = distance;
                closestWallMesh = plane.planeMesh;
                console.log("Updated closest wall at distance:", distance);
              }
            }
          }
          // Once both floor and a wall are detected, initialize ball and hoop.
          if (floorConfigured && closestWallMesh && !ballAndHoopCreated) {
            // Set ball position relative to floor.
            const ballPos = { x: 0, y: BALL_RADIUS + floorOffset, z: -1 };
            createBallPhysics(ballPos);
            createBallVisual(ballPos);
            // Compute hoop position using wall data:
            const wallNormal = new THREE.Vector3(0, 0, 1)
              .applyQuaternion(closestWallMesh.quaternion)
              .normalize();
            const wallPos = new THREE.Vector3();
            closestWallMesh.getWorldPosition(wallPos);
            const hoopPos = wallPos.clone().addScaledVector(wallNormal, HOOP_RADIUS + 0.2);
            hoopPos.y = HOOP_HEIGHT + floorOffset;
            createHoopPhysics(hoopPos);
            createHoopVisual(hoopPos);
            ballAndHoopCreated = true;
            console.log("Ball and hoop created.");
          }
        };

        // Setup controllers with hand models:
        const gltfLoader = new GLTFLoader();
        for (let i = 0; i < 2; i++) {
          const controller = renderer.xr.getController(i);
          controller.userData.index = i;
          controller.userData.velocity = new THREE.Vector3();
          controller.addEventListener("connected", (event) => {
            controller.userData.handedness = event.data.handedness;
            const url =
              controller.userData.handedness === "left"
                ? "https://raw.githubusercontent.com/immersive-web/webxr-input-profiles/main/packages/assets/profiles/generic-hand/left.glb"
                : "https://raw.githubusercontent.com/immersive-web/webxr-input-profiles/main/packages/assets/profiles/generic-hand/right.glb";
            gltfLoader.load(
              url,
              (gltf) => {
                const handWrapper = new THREE.Group();
                const handModel = gltf.scene;
                handModel.rotation.set(Math.PI / 2, 0, 0);
                handWrapper.add(handModel);
                controller.add(handWrapper);
              },
              undefined,
              (error) => {
                console.error("Error loading hand model:", error);
              }
            );
          });
          controller.addEventListener("squeezestart", onGrab);
          controller.addEventListener("squeezeend", onRelease);
          scene.add(controller);
          controllers.push(controller);
        }
        renderer.setAnimationLoop(animate);
      }

      // AR Button: Request immersive-ar session and initialize game logic.
      document.getElementById("ar-button").addEventListener("click", async () => {
        try {
          const session = await navigator.xr.requestSession("immersive-ar", {
            requiredFeatures: ["hit-test", "plane-detection", "anchors"],
            optionalFeatures: ["mesh-detection"],
          });
          renderer.xr.setReferenceSpaceType("local");
          renderer.xr.setSession(session);
          console.log("AR session started.");
          initGame();
        } catch (err) {
          console.error("Failed to start AR session:", err);
        }
      });
    </script>
  </body>
</html>
