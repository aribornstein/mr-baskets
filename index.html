<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Passthrough Basketball Game for Quest 3</title>
  <script type="importmap">
    {
      "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.146.0/build/three.module.js"
      }
    }
  </script>
  <style>
    body { margin: 0; overflow: hidden; background: none; }
    canvas { display: block; background: none; }
    #ar-button {
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      padding: 12px 24px;
      font-size: 16px;
      z-index: 100;
    }
  </style>
</head>
<body>
  <button id="ar-button">Enter AR</button>
  <script type="module">
    import * as THREE from "three";
    import { GLTFLoader } from "https://cdn.jsdelivr.net/npm/three@0.146.0/examples/jsm/loaders/GLTFLoader.js";
    import * as RAPIER from "https://cdn.jsdelivr.net/npm/@dimforge/rapier3d-compat@0.14.0/rapier.es.js";
    import { RealityAccelerator } from "https://unpkg.com/ratk@0.3.0";

    // Global variables
    let scene, camera, renderer, clock;
    let rapierWorld;
    let basketballMesh, hoopMesh, backboardMesh;
    let ballRigidBody = null, ballCollider = null;
    let hoopBody = null, boardBody = null;
    let groundMesh;
    let ratk;
    let floorConfigured = false;      // Set when a valid floor surface is detected
    let groundCreated = false;        // Create ground only once
    let ballAndHoopCreated = false;   // Only create ball and hoop once
    let floorOffset = 0;
    let isHoldingBall = false;
    const controllers = [];
    const BALL_RADIUS = 0.12, HOOP_RADIUS = 0.3, HOOP_HEIGHT = 1.8;
    // Global room boundary computed from detected walls.
    let roomBoundary = null;
    let wallsCreated = false;

    // Create renderer with transparency (for passthrough)
    renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.xr.enabled = true;
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setClearColor(0x000000, 0);
    document.body.appendChild(renderer.domElement);

    // Create scene and camera
    scene = new THREE.Scene();
    scene.background = null;
    camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.01, 20);
    camera.position.set(0, 1.6, 0);
    scene.add(camera);

    // Add lighting
    const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 0.6);
    scene.add(hemiLight);
    const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
    dirLight.position.set(0, 4, 2);
    scene.add(dirLight);

    // Resize handler
    window.addEventListener("resize", () => {
      if (!renderer.xr.getSession()) {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      }
    });

    // --- Game Logic Functions ---

    function createGroundPhysics() {
      const groundBodyDesc = RAPIER.RigidBodyDesc.fixed().setTranslation(0, floorOffset, 0);
      const groundBody = rapierWorld.createRigidBody(groundBodyDesc);
      const groundColliderDesc = RAPIER.ColliderDesc.cuboid(5, 0.1, 5)
        .setRestitution(0.7)
        .setFriction(0.8);
      rapierWorld.createCollider(groundColliderDesc, groundBody);
    }
    function createGroundVisual() {
      const groundGeo = new THREE.CircleGeometry(5, 32);
      const groundMat = new THREE.MeshStandardMaterial({
        color: 0x333333,
        side: THREE.DoubleSide,
        transparent: true,
        opacity: 0.1,
      });
      groundMesh = new THREE.Mesh(groundGeo, groundMat);
      groundMesh.rotation.x = -Math.PI / 2;
      groundMesh.position.y = floorOffset;
      scene.add(groundMesh);
    }
    function createBallPhysics(pos) {
      const bodyDesc = RAPIER.RigidBodyDesc.dynamic().setTranslation(pos.x, pos.y, pos.z);
      ballRigidBody = rapierWorld.createRigidBody(bodyDesc);
      const colliderDesc = RAPIER.ColliderDesc.ball(BALL_RADIUS)
        .setRestitution(0.7)
        .setFriction(0.7);
      ballCollider = rapierWorld.createCollider(colliderDesc, ballRigidBody);
    }
    function createBallVisual(pos) {
      const geometry = new THREE.SphereGeometry(BALL_RADIUS, 32, 32);
      const material = new THREE.MeshStandardMaterial({ color: 0xff8c00 });
      basketballMesh = new THREE.Mesh(geometry, material);
      basketballMesh.position.set(pos.x, pos.y, pos.z);
      scene.add(basketballMesh);
    }
    function createHoopPhysics(pos) {
      const hoopBodyDesc = RAPIER.RigidBodyDesc.fixed().setTranslation(pos.x, pos.y, pos.z);
      hoopBody = rapierWorld.createRigidBody(hoopBodyDesc);
      const ringColliderDesc = RAPIER.ColliderDesc.cylinder(0.02, HOOP_RADIUS)
        .setRestitution(0.5)
        .setFriction(0.8);
      const dummy = new THREE.Object3D();
      dummy.position.set(pos.x, pos.y, pos.z);
      dummy.lookAt(camera.position);
      const correction = new THREE.Quaternion().setFromEuler(new THREE.Euler(Math.PI / 2, 0, 0));
      const hoopQuat = dummy.quaternion.clone().multiply(correction);
      ringColliderDesc.setRotation({ x: hoopQuat.x, y: hoopQuat.y, z: hoopQuat.z, w: hoopQuat.w });
      rapierWorld.createCollider(ringColliderDesc, hoopBody);

      const boardBodyDesc = RAPIER.RigidBodyDesc.fixed().setTranslation(pos.x, pos.y, pos.z - 0.05);
      boardBody = rapierWorld.createRigidBody(boardBodyDesc);
      const boardColliderDesc = RAPIER.ColliderDesc.cuboid(0.3, 0.2, 0.01)
        .setRestitution(0.3)
        .setFriction(0.8);
      rapierWorld.createCollider(boardColliderDesc, boardBody);
    }
    function createHoopVisual(pos) {
      console.log("Creating hoop at:", pos);
      const hoopGeometry = new THREE.TorusGeometry(HOOP_RADIUS, 0.02, 16, 100);
      const hoopMaterial = new THREE.MeshStandardMaterial({ color: 0xff0000 });
      hoopMesh = new THREE.Mesh(hoopGeometry, hoopMaterial);
      hoopMesh.rotation.x = Math.PI / 2;
      hoopMesh.position.set(pos.x, pos.y, pos.z);
      scene.add(hoopMesh);
      const boardGeometry = new THREE.PlaneGeometry(0.6, 0.4);
      const boardMaterial = new THREE.MeshStandardMaterial({
        color: 0x0000ff,
        side: THREE.DoubleSide
      });
      backboardMesh = new THREE.Mesh(boardGeometry, boardMaterial);
      backboardMesh.position.set(pos.x, pos.y, pos.z);
      backboardMesh.translateZ(-0.1);
      backboardMesh.translateY(0.1);
      scene.add(backboardMesh);
    }
    function createRoomWalls(rapierWorld, roomBoundary) {
      const padding = 0.2;
      const wallThickness = 0.1;
      const halfThickness = wallThickness / 2;
      const centerX = (roomBoundary.min.x + roomBoundary.max.x) / 2;
      const centerY = (roomBoundary.min.y + roomBoundary.max.y) / 2;
      const centerZ = (roomBoundary.min.z + roomBoundary.max.z) / 2;
      const halfWidth = (roomBoundary.max.x - roomBoundary.min.x) / 2;
      const halfHeight = (roomBoundary.max.y - roomBoundary.min.y) / 2;
      const halfDepth = (roomBoundary.max.z - roomBoundary.min.z) / 2;
      {
        const xPos = roomBoundary.min.x - padding;
        const wallBodyDesc = RAPIER.RigidBodyDesc.fixed().setTranslation(xPos, centerY, centerZ);
        const wallBody = rapierWorld.createRigidBody(wallBodyDesc);
        const wallColliderDesc = RAPIER.ColliderDesc.cuboid(halfThickness, halfHeight, halfDepth);
        rapierWorld.createCollider(wallColliderDesc, wallBody);
      }
      {
        const xPos = roomBoundary.max.x + padding;
        const wallBodyDesc = RAPIER.RigidBodyDesc.fixed().setTranslation(xPos, centerY, centerZ);
        const wallBody = rapierWorld.createRigidBody(wallBodyDesc);
        const wallColliderDesc = RAPIER.ColliderDesc.cuboid(halfThickness, halfHeight, halfDepth);
        rapierWorld.createCollider(wallColliderDesc, wallBody);
      }
      {
        const zPos = roomBoundary.min.z - padding;
        const wallBodyDesc = RAPIER.RigidBodyDesc.fixed().setTranslation(centerX, centerY, zPos);
        const wallBody = rapierWorld.createRigidBody(wallBodyDesc);
        const wallColliderDesc = RAPIER.ColliderDesc.cuboid(halfWidth, halfHeight, halfThickness);
        rapierWorld.createCollider(wallColliderDesc, wallBody);
      }
      {
        const zPos = roomBoundary.max.z + padding;
        const wallBodyDesc = RAPIER.RigidBodyDesc.fixed().setTranslation(centerX, centerY, zPos);
        const wallBody = rapierWorld.createRigidBody(wallBodyDesc);
        const wallColliderDesc = RAPIER.ColliderDesc.cuboid(halfWidth, halfHeight, halfThickness);
        rapierWorld.createCollider(wallColliderDesc, wallBody);
      }
      console.log("Room boundary walls created with padding:", padding);
    }

    // Instead of QueryPipeline-based raycasting, we clamp the ballâ€™s position directly.
    function clampBallPosition() {
      if (ballRigidBody && roomBoundary) {
        const t = ballRigidBody.translation();
        const clampedX = THREE.MathUtils.clamp(t.x, roomBoundary.min.x + BALL_RADIUS, roomBoundary.max.x - BALL_RADIUS);
        const clampedZ = THREE.MathUtils.clamp(t.z, roomBoundary.min.z + BALL_RADIUS, roomBoundary.max.z - BALL_RADIUS);
        if (t.x !== clampedX || t.z !== clampedZ) {
          ballRigidBody.setTranslation({ x: clampedX, y: t.y, z: clampedZ }, true);
          ballRigidBody.setLinvel({ x: 0, y: 0, z: 0 }, true);
        }
      }
    }

    function onGrab(event) {
      const controller = event.target;
      if (!basketballMesh) {
        console.warn("No basketballMesh available to grab.");
        return;
      }
      if (!isHoldingBall) {
        if (ballRigidBody) {
          rapierWorld.removeRigidBody(ballRigidBody);
          ballRigidBody = null;
          ballCollider = null;
        }
        if (basketballMesh.parent) {
          basketballMesh.parent.remove(basketballMesh);
        }
        controller.add(basketballMesh);
        if (controller.userData.handedness === "left") {
          basketballMesh.position.set(0.1, 0.0, -0.08);
        } else {
          basketballMesh.position.set(-0.1, 0.0, -0.08);
        }
        isHoldingBall = true;
      } else {
        const currentHolder = basketballMesh.parent;
        if (currentHolder !== controller) {
          if (currentHolder) currentHolder.remove(basketballMesh);
          controller.add(basketballMesh);
          if (controller.userData.handedness === "left") {
            basketballMesh.position.set(0.1, 0.0, -0.08);
          } else {
            basketballMesh.position.set(-0.1, 0.0, -0.08);
          }
        }
      }
    }
    function onRelease(event) {
      const controller = event.target;
      if (!basketballMesh) {
        console.warn("No basketballMesh available to release.");
        return;
      }
      if (isHoldingBall) {
        isHoldingBall = false;
        basketballMesh.updateMatrixWorld();
        const worldPos = new THREE.Vector3();
        basketballMesh.getWorldPosition(worldPos);
        if (basketballMesh.parent) {
          basketballMesh.parent.remove(basketballMesh);
        }
        scene.add(basketballMesh);
        basketballMesh.position.copy(worldPos);
        createBallPhysics({ x: worldPos.x, y: worldPos.y, z: worldPos.z });
        const throwVelocity = controller.userData.velocity || new THREE.Vector3();
        ballRigidBody.setLinvel({ x: throwVelocity.x, y: throwVelocity.y, z: throwVelocity.z }, true);
      }
    }

    // Fixed timestep physics loop
    const fixedTimeStep = 1 / 60;
    let accumulator = 0;
    const clockGame = new THREE.Clock();
    function animate() {
      const delta = clockGame.getDelta();
      accumulator += delta;
      while (accumulator >= fixedTimeStep) {
        if (rapierWorld) rapierWorld.step();
        accumulator -= fixedTimeStep;
      }
      controllers.forEach(controller => {
        const currentPos = new THREE.Vector3().setFromMatrixPosition(controller.matrixWorld);
        if (controller.userData.prevPos) {
          const velocity = new THREE.Vector3().subVectors(currentPos, controller.userData.prevPos).divideScalar(delta);
          controller.userData.velocity.copy(velocity);
        }
        controller.userData.prevPos = currentPos.clone();
      });
      if (ratk && typeof ratk.update === "function") {
        ratk.update();
      }
      if (ballAndHoopCreated && ballRigidBody && basketballMesh && !isHoldingBall) {
        const t = ballRigidBody.translation();
        basketballMesh.position.set(t.x, t.y, t.z);
        const r = ballRigidBody.rotation();
        basketballMesh.quaternion.set(r.x, r.y, r.z, r.w);
        // Instead of using QueryPipeline, we simply clamp the ball's position.
        clampBallPosition();
      }
      renderer.render(scene, camera);
    }

    function handleSurfaceAdded(event) {
      const surfaceMesh = event.planeMesh || event.meshMesh;
      if (!surfaceMesh || !event.semanticLabel) return;
      const label = event.semanticLabel.toLowerCase();
      console.log("Surface added:", label);
      if (label === "floor" && !floorConfigured) {
        const box = new THREE.Box3().setFromObject(surfaceMesh);
        floorOffset = box.min.y;
        floorConfigured = true;
        console.log("Floor configured at:", floorOffset);
        if (!groundCreated) {
          createGroundPhysics();
          // createGroundVisual();
          groundCreated = true;
        }
      }
      if (label === "wall") {
        const wallBox = new THREE.Box3().setFromObject(surfaceMesh);
        if (roomBoundary === null) {
          roomBoundary = wallBox;
        } else {
          roomBoundary.union(wallBox);
        }
        console.log("Updated room boundary:", roomBoundary);
        if (!wallsCreated && roomBoundary && rapierWorld) {
          createRoomWalls(rapierWorld, roomBoundary);
          wallsCreated = true;
        }
      }
      if (floorConfigured && !ballAndHoopCreated) {
        const ballOffset = new THREE.Vector3(0, 0, -1);
        ballOffset.applyQuaternion(camera.quaternion);
        const ballPos = camera.position.clone().add(ballOffset);
        ballPos.y = BALL_RADIUS + floorOffset;
        if (roomBoundary) {
          ballPos.x = THREE.MathUtils.clamp(ballPos.x, roomBoundary.min.x + BALL_RADIUS, roomBoundary.max.x - BALL_RADIUS);
          ballPos.z = THREE.MathUtils.clamp(ballPos.z, roomBoundary.min.z + BALL_RADIUS, roomBoundary.max.z - BALL_RADIUS);
        }
        createBallPhysics(ballPos);
        createBallVisual(ballPos);
        const hoopOffset = new THREE.Vector3(0, 0, -2.5);
        hoopOffset.applyQuaternion(camera.quaternion);
        const hoopPos = camera.position.clone().add(hoopOffset);
        hoopPos.y = HOOP_HEIGHT + floorOffset;
        if (roomBoundary) {
          hoopPos.x = THREE.MathUtils.clamp(hoopPos.x, roomBoundary.min.x + HOOP_RADIUS, roomBoundary.max.x - HOOP_RADIUS);
          hoopPos.z = THREE.MathUtils.clamp(hoopPos.z, roomBoundary.min.z + HOOP_RADIUS, roomBoundary.max.z - HOOP_RADIUS);
        }
        createHoopPhysics(hoopPos);
        createHoopVisual(hoopPos);
        ballAndHoopCreated = true;
        console.log("Ball and hoop created relative to the camera within room bounds.");
      }
    }

    async function initGame() {
      clock = new THREE.Clock();
      await RAPIER.init();
      rapierWorld = new RAPIER.World({ x: 0, y: -9.8, z: 0 });
      // Initialize QueryPipeline if needed in future.
      // For now we use clamping so we don't call QueryPipeline methods.
      // queryPipeline = new RAPIER.QueryPipeline();
      ratk = new RealityAccelerator(renderer.xr);
      scene.add(ratk.root);
      ratk.root.visible = false;
      ratk.onPlaneAdded = handleSurfaceAdded;
      ratk.onMeshAdded = handleSurfaceAdded;
      const gltfLoader = new GLTFLoader();
      for (let i = 0; i < 2; i++) {
        const controller = renderer.xr.getController(i);
        controller.userData.index = i;
        controller.userData.velocity = new THREE.Vector3();
        controller.addEventListener("connected", (event) => {
          controller.userData.handedness = event.data.handedness;
          const url =
            controller.userData.handedness === "left"
              ? "https://raw.githubusercontent.com/immersive-web/webxr-input-profiles/main/packages/assets/profiles/generic-hand/left.glb"
              : "https://raw.githubusercontent.com/immersive-web/webxr-input-profiles/main/packages/assets/profiles/generic-hand/right.glb";
          gltfLoader.load(
            url,
            (gltf) => {
              const handWrapper = new THREE.Group();
              const handModel = gltf.scene;
              handModel.rotation.set(Math.PI / 2, 0, 0);
              handWrapper.add(handModel);
              controller.add(handWrapper);
            },
            undefined,
            (error) => {
              console.error("Error loading hand model:", error);
            }
          );
        });
        controller.addEventListener("squeezestart", onGrab);
        controller.addEventListener("squeezeend", onRelease);
        scene.add(controller);
        controllers.push(controller);
      }
      renderer.setAnimationLoop(animate);
    }

    document.getElementById("ar-button").addEventListener("click", async () => {
      try {
        const session = await navigator.xr.requestSession("immersive-ar", {
          requiredFeatures: ["local-floor", "hit-test", "plane-detection", "anchors"],
          optionalFeatures: ["mesh-detection"],
        });
        renderer.xr.setReferenceSpaceType("local-floor");
        renderer.xr.setSession(session);
        console.log("AR session started.");
        initGame();
      } catch (err) {
        console.error("Failed to start AR session:", err);
      }
    });
  </script>
</body>
</html>
