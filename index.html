<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Passthrough Basketball Game for Quest 3</title>
  <script type="importmap">
      {
        "imports": {
          "three": "https://cdn.jsdelivr.net/npm/three@0.146.0/build/three.module.js"
        }
      }
    </script>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background: none;
    }

    canvas {
      display: block;
      background: none;
    }

    #ar-button {
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      padding: 12px 24px;
      font-size: 16px;
      z-index: 100;
    }
  </style>
</head>

<body>
  <button id="ar-button">Enter AR</button>
  <script type="module">
    import * as THREE from "three";
    import { GLTFLoader } from "https://cdn.jsdelivr.net/npm/three@0.146.0/examples/jsm/loaders/GLTFLoader.js";
    import * as RAPIER from "https://cdn.jsdelivr.net/npm/@dimforge/rapier3d-compat@0.14.0/rapier.es.js";
    import { RealityAccelerator } from "https://unpkg.com/ratk@0.3.0";

    // Global variables
    let scene, camera, renderer, clock;
    let rapierWorld;
    let queryPipeline; // <-- Added QueryPipeline for manual raycasting.
    let basketballMesh, hoopMesh, backboardMesh;
    let ballRigidBody = null, ballCollider = null;
    let hoopBody = null, boardBody = null;
    let groundMesh;
    let ratk;
    let floorConfigured = false;      // Set when a valid floor surface is detected
    let groundCreated = false;        // Create ground only once
    let ballAndHoopCreated = false;   // Only create ball and hoop once
    let floorOffset = 0;
    let isHoldingBall = false;
    const controllers = [];
    const BALL_RADIUS = 0.12, HOOP_RADIUS = 0.3, HOOP_HEIGHT = 1.8;
    // Global room boundary computed from detected walls.
    let roomBoundary = null;
    // Flag to ensure walls are only created once.
    let wallsCreated = false;

    // Create renderer with transparency (for passthrough)
    renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.xr.enabled = true;
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setClearColor(0x000000, 0);
    document.body.appendChild(renderer.domElement);

    // Create scene and camera
    scene = new THREE.Scene();
    scene.background = null;
    camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.01, 20);
    camera.position.set(0, 1.6, 0);
    scene.add(camera);

    // Add lighting
    const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 0.6);
    scene.add(hemiLight);
    const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
    dirLight.position.set(0, 4, 2);
    scene.add(dirLight);

    // Resize handler (only if XR session is not active)
    window.addEventListener("resize", () => {
      if (!renderer.xr.getSession()) {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      }
    });

    // --- Game Logic Functions ---

    function createGroundPhysics() {
      const groundBodyDesc = RAPIER.RigidBodyDesc.fixed().setTranslation(0, floorOffset, 0);
      const groundBody = rapierWorld.createRigidBody(groundBodyDesc);
      const groundColliderDesc = RAPIER.ColliderDesc.cuboid(5, 0.1, 5)
        .setRestitution(0.7)
        .setFriction(0.8);
      rapierWorld.createCollider(groundColliderDesc, groundBody);
    }
    function createGroundVisual() {
      const groundGeo = new THREE.CircleGeometry(5, 32);
      const groundMat = new THREE.MeshStandardMaterial({
        color: 0x333333,
        side: THREE.DoubleSide,
        transparent: true,
        opacity: 0.1,
      });
      groundMesh = new THREE.Mesh(groundGeo, groundMat);
      groundMesh.rotation.x = -Math.PI / 2;
      groundMesh.position.y = floorOffset;
      scene.add(groundMesh);
    }

    function createBallPhysics(pos) {
      const bodyDesc = RAPIER.RigidBodyDesc.dynamic()
        .setTranslation(pos.x, pos.y, pos.z);
      ballRigidBody = rapierWorld.createRigidBody(bodyDesc);
      const colliderDesc = RAPIER.ColliderDesc.ball(BALL_RADIUS)
        .setRestitution(0.7)
        .setFriction(0.7);
      ballCollider = rapierWorld.createCollider(colliderDesc, ballRigidBody);
    }

    function createBallVisual(pos) {
      const geometry = new THREE.SphereGeometry(BALL_RADIUS, 32, 32);
      const material = new THREE.MeshStandardMaterial({ color: 0xff8c00 });
      basketballMesh = new THREE.Mesh(geometry, material);
      basketballMesh.position.set(pos.x, pos.y, pos.z);
      scene.add(basketballMesh);
    }
    function createHoopPhysics(pos) {
      // Create the hoop rigid body at the given position.
      const hoopBodyDesc = RAPIER.RigidBodyDesc.fixed().setTranslation(pos.x, pos.y, pos.z);
      hoopBody = rapierWorld.createRigidBody(hoopBodyDesc);

      // Create a collider for the hoop ring.
      const ringColliderDesc = RAPIER.ColliderDesc.cylinder(0.02, HOOP_RADIUS)
        .setRestitution(0.5)
        .setFriction(0.8);

      // Compute a quaternion so the hoop faces the camera.
      const dummy = new THREE.Object3D();
      dummy.position.set(pos.x, pos.y, pos.z);
      dummy.lookAt(camera.position);
      // Apply a correction so that the torus (which is rotated by Ï€/2 in the visual) aligns.
      const correction = new THREE.Quaternion().setFromEuler(new THREE.Euler(Math.PI / 2, 0, 0));
      const hoopQuat = dummy.quaternion.clone().multiply(correction);
      ringColliderDesc.setRotation({ x: hoopQuat.x, y: hoopQuat.y, z: hoopQuat.z, w: hoopQuat.w });

      rapierWorld.createCollider(ringColliderDesc, hoopBody);

      // Create the backboard physics.
      const boardBodyDesc = RAPIER.RigidBodyDesc.fixed().setTranslation(pos.x, pos.y, pos.z - 0.05);
      boardBody = rapierWorld.createRigidBody(boardBodyDesc);
      const boardColliderDesc = RAPIER.ColliderDesc.cuboid(0.3, 0.2, 0.01)
        .setRestitution(0.3)
        .setFriction(0.8);
      rapierWorld.createCollider(boardColliderDesc, boardBody);
    }
    function createHoopVisual(pos) {
      console.log("Creating hoop at:", pos);
      // 1) Create the hoop (torus).
      const hoopGeometry = new THREE.TorusGeometry(HOOP_RADIUS, 0.02, 16, 100);
      const hoopMaterial = new THREE.MeshStandardMaterial({ color: 0xff0000 });
      hoopMesh = new THREE.Mesh(hoopGeometry, hoopMaterial);
      // Rotate the ring so it's facing outward.
      hoopMesh.rotation.x = Math.PI / 2;
      // Position the ring at the desired anchor point.
      hoopMesh.position.set(pos.x, pos.y, pos.z);
      scene.add(hoopMesh);
      // 2) Create the backboard (plane).
      const boardGeometry = new THREE.PlaneGeometry(0.6, 0.4);
      const boardMaterial = new THREE.MeshStandardMaterial({
        color: 0x0000ff,
        side: THREE.DoubleSide  // So it's visible from both sides
      });
      backboardMesh = new THREE.Mesh(boardGeometry, boardMaterial);
      // Start by placing the board at the same spot as the hoop.
      backboardMesh.position.set(pos.x, pos.y, pos.z);
      // 3) Translate the board behind and above the hoop:
      backboardMesh.translateZ(-0.1);   // Adjust to taste (e.g. -0.15)
      backboardMesh.translateY(0.1);    // Adjust as needed
      scene.add(backboardMesh);
    }

    // Create invisible room boundary walls with padding so the ball doesn't leave the room.
    function createRoomWalls(rapierWorld, roomBoundary) {
      const padding = 0.2; // Additional padding (in meters)
      const wallThickness = 0.1; // Total wall thickness in meters
      const halfThickness = wallThickness / 2; // 0.05

      // Compute room dimensions
      const centerX = (roomBoundary.min.x + roomBoundary.max.x) / 2;
      const centerY = (roomBoundary.min.y + roomBoundary.max.y) / 2;
      const centerZ = (roomBoundary.min.z + roomBoundary.max.z) / 2;
      const halfWidth = (roomBoundary.max.x - roomBoundary.min.x) / 2;
      const halfHeight = (roomBoundary.max.y - roomBoundary.min.y) / 2;
      const halfDepth = (roomBoundary.max.z - roomBoundary.min.z) / 2;

      // Left wall (x = min - padding)
      {
        const xPos = roomBoundary.min.x - padding;
        const wallBodyDesc = RAPIER.RigidBodyDesc.fixed().setTranslation(xPos, centerY, centerZ);
        const wallBody = rapierWorld.createRigidBody(wallBodyDesc);
        const wallColliderDesc = RAPIER.ColliderDesc.cuboid(halfThickness, halfHeight, halfDepth);
        rapierWorld.createCollider(wallColliderDesc, wallBody);
      }
      // Right wall (x = max + padding)
      {
        const xPos = roomBoundary.max.x + padding;
        const wallBodyDesc = RAPIER.RigidBodyDesc.fixed().setTranslation(xPos, centerY, centerZ);
        const wallBody = rapierWorld.createRigidBody(wallBodyDesc);
        const wallColliderDesc = RAPIER.ColliderDesc.cuboid(halfThickness, halfHeight, halfDepth);
        rapierWorld.createCollider(wallColliderDesc, wallBody);
      }
      // Front wall (z = min - padding)
      {
        const zPos = roomBoundary.min.z - padding;
        const wallBodyDesc = RAPIER.RigidBodyDesc.fixed().setTranslation(centerX, centerY, zPos);
        const wallBody = rapierWorld.createRigidBody(wallBodyDesc);
        const wallColliderDesc = RAPIER.ColliderDesc.cuboid(halfWidth, halfHeight, halfThickness);
        rapierWorld.createCollider(wallColliderDesc, wallBody);
      }
      // Back wall (z = max + padding)
      {
        const zPos = roomBoundary.max.z + padding;
        const wallBodyDesc = RAPIER.RigidBodyDesc.fixed().setTranslation(centerX, centerY, zPos);
        const wallBody = rapierWorld.createRigidBody(wallBodyDesc);
        const wallColliderDesc = RAPIER.ColliderDesc.cuboid(halfWidth, halfHeight, halfThickness);
        rapierWorld.createCollider(wallColliderDesc, wallBody);
      }
      console.log("Room boundary walls created with padding:", padding);
    }

    // --- Raycasting helper for ball boundaries ---
    function updateBallRaycast(delta) {
      if (ballRigidBody && basketballMesh && !isHoldingBall) {
        // Get the current translation and linear velocity from the physics body.
        const t = ballRigidBody.translation();
        const linvel = ballRigidBody.linvel();
        // Compute speed
        const speed = Math.sqrt(linvel.x * linvel.x + linvel.y * linvel.y + linvel.z * linvel.z);
        if (speed > 0) {
          // Normalize velocity to obtain the ray direction.
          const direction = { x: linvel.x / speed, y: linvel.y / speed, z: linvel.z / speed };
          // Use fixedTimeStep as the prediction window.
          const maxDistance = speed * fixedTimeStep;
          // Create a ray from the current position.
          const rayOrigin = { x: t.x, y: t.y, z: t.z };
          const ray = new RAPIER.Ray(rayOrigin, direction);
          // Update the query pipeline so it has the latest world state.
          // (Assumes rapierWorld exposes rigidBodySet and colliderSet)
          queryPipeline.update(rapierWorld.rigidBodySet, rapierWorld.colliderSet);
          // Perform the raycast. The 'true' parameter indicates we treat colliders as solid.
          const result = queryPipeline.castRay(
            rapierWorld.rigidBodySet,
            rapierWorld.colliderSet,
            ray,
            maxDistance,
            true,
            RAPIER.QueryFilter.default()
          );
          if (result) {
            // If a collision is predicted ahead, clamp the ball to the hit point.
            const hitPoint = ray.pointAt(result.toi);
            ballRigidBody.setTranslation(hitPoint, true);
            ballRigidBody.setLinvel({ x: 0, y: 0, z: 0 }, true);
          }
        }
      }
    }

    // onGrab and onRelease (with guard checks)
    function onGrab(event) {
      const controller = event.target;
      if (!basketballMesh) {
        console.warn("No basketballMesh available to grab.");
        return;
      }
      if (!isHoldingBall) {
        if (ballRigidBody) {
          rapierWorld.removeRigidBody(ballRigidBody);
          ballRigidBody = null;
          ballCollider = null;
        }
        if (basketballMesh.parent) {
          basketballMesh.parent.remove(basketballMesh);
        }
        controller.add(basketballMesh);
        if (controller.userData.handedness === "left") {
          basketballMesh.position.set(0.1, 0.0, -0.08);
        } else {
          basketballMesh.position.set(-0.1, 0.0, -0.08);
        }
        isHoldingBall = true;
      } else {
        const currentHolder = basketballMesh.parent;
        if (currentHolder !== controller) {
          if (currentHolder) currentHolder.remove(basketballMesh);
          controller.add(basketballMesh);
          if (controller.userData.handedness === "left") {
            basketballMesh.position.set(0.1, 0.0, -0.08);
          } else {
            basketballMesh.position.set(-0.1, 0.0, -0.08);
          }
        }
      }
    }
    function onRelease(event) {
      const controller = event.target;
      if (!basketballMesh) {
        console.warn("No basketballMesh available to release.");
        return;
      }
      if (isHoldingBall) {
        isHoldingBall = false;
        basketballMesh.updateMatrixWorld();
        const worldPos = new THREE.Vector3();
        basketballMesh.getWorldPosition(worldPos);
        if (basketballMesh.parent) {
          basketballMesh.parent.remove(basketballMesh);
        }
        scene.add(basketballMesh);
        basketballMesh.position.copy(worldPos);
        createBallPhysics({ x: worldPos.x, y: worldPos.y, z: worldPos.z });
        const throwVelocity = controller.userData.velocity || new THREE.Vector3();
        ballRigidBody.setLinvel({ x: throwVelocity.x, y: throwVelocity.y, z: throwVelocity.z }, true);
      }
    }

    // Fixed timestep physics loop
    const fixedTimeStep = 1 / 60;
    let accumulator = 0;
    const clockGame = new THREE.Clock();
    function animate() {
      const delta = clockGame.getDelta();
      accumulator += delta;
      while (accumulator >= fixedTimeStep) {
        if (rapierWorld) rapierWorld.step();
        accumulator -= fixedTimeStep;
      }

      // Update controllers' velocity:
      controllers.forEach(controller => {
        const currentPos = new THREE.Vector3().setFromMatrixPosition(controller.matrixWorld);
        if (controller.userData.prevPos) {
          const velocity = new THREE.Vector3().subVectors(currentPos, controller.userData.prevPos).divideScalar(delta);
          controller.userData.velocity.copy(velocity);
        }
        controller.userData.prevPos = currentPos.clone();
      });

      if (ratk && typeof ratk.update === "function") {
        ratk.update();
      }

      // Update ball visual from physics simulation and run raycast check:
      if (ballAndHoopCreated && ballRigidBody && basketballMesh && !isHoldingBall) {
        const t = ballRigidBody.translation();
        basketballMesh.position.set(t.x, t.y, t.z);
        const r = ballRigidBody.rotation();
        basketballMesh.quaternion.set(r.x, r.y, r.z, r.w);

        // Apply manual raycast to prevent ball from leaving the room.
        updateBallRaycast(fixedTimeStep);
      }
      renderer.render(scene, camera);
    }

    // Handler for detected surfaces.
    function handleSurfaceAdded(event) {
      const surfaceMesh = event.planeMesh || event.meshMesh;
      if (!surfaceMesh || !event.semanticLabel) return;
      const label = event.semanticLabel.toLowerCase();
      console.log("Surface added:", label);
      if (label === "floor" && !floorConfigured) {
        const box = new THREE.Box3().setFromObject(surfaceMesh);
        floorOffset = box.min.y;
        floorConfigured = true;
        console.log("Floor configured at:", floorOffset);
        if (!groundCreated) {
          createGroundPhysics();
          createGroundVisual();
          groundCreated = true;
        }
      }
      if (label === "wall") {
        const wallBox = new THREE.Box3().setFromObject(surfaceMesh);
        if (roomBoundary === null) {
          roomBoundary = wallBox;
        } else {
          roomBoundary.union(wallBox);
        }
        console.log("Updated room boundary:", roomBoundary);
        if (!wallsCreated && roomBoundary && rapierWorld) {
          createRoomWalls(rapierWorld, roomBoundary);
          wallsCreated = true;
        }
      }
      if (floorConfigured && !ballAndHoopCreated) {
        const ballOffset = new THREE.Vector3(0, 0, -1);
        ballOffset.applyQuaternion(camera.quaternion);
        const ballPos = camera.position.clone().add(ballOffset);
        ballPos.y = BALL_RADIUS + floorOffset;
        if (roomBoundary) {
          ballPos.x = THREE.MathUtils.clamp(ballPos.x, roomBoundary.min.x + BALL_RADIUS, roomBoundary.max.x - BALL_RADIUS);
          ballPos.z = THREE.MathUtils.clamp(ballPos.z, roomBoundary.min.z + BALL_RADIUS, roomBoundary.max.z - BALL_RADIUS);
        }
        createBallPhysics(ballPos);
        createBallVisual(ballPos);

        const hoopOffset = new THREE.Vector3(0, 0, -2.5);
        hoopOffset.applyQuaternion(camera.quaternion);
        const hoopPos = camera.position.clone().add(hoopOffset);
        hoopPos.y = HOOP_HEIGHT + floorOffset;
        if (roomBoundary) {
          hoopPos.x = THREE.MathUtils.clamp(hoopPos.x, roomBoundary.min.x + HOOP_RADIUS, roomBoundary.max.x - HOOP_RADIUS);
          hoopPos.z = THREE.MathUtils.clamp(hoopPos.z, roomBoundary.min.z + HOOP_RADIUS, roomBoundary.max.z - HOOP_RADIUS);
        }
        createHoopPhysics(hoopPos);
        createHoopVisual(hoopPos);

        ballAndHoopCreated = true;
        console.log("Ball and hoop created relative to the camera within room bounds.");
      }
    }

    // Initialize AR game logic.
    async function initGame() {
      clock = new THREE.Clock();
      await RAPIER.init();
      rapierWorld = new RAPIER.World({ x: 0, y: -9.8, z: 0 });
      // Initialize the QueryPipeline for manual raycasting.
      queryPipeline = new RAPIER.QueryPipeline();

      // Setup RealityAccelerator for surface detection.
      ratk = new RealityAccelerator(renderer.xr);
      scene.add(ratk.root);
      ratk.root.visible = false;
      ratk.onPlaneAdded = handleSurfaceAdded;
      ratk.onMeshAdded = handleSurfaceAdded;

      // Setup controllers with virtual hand models.
      const gltfLoader = new GLTFLoader();
      for (let i = 0; i < 2; i++) {
        const controller = renderer.xr.getController(i);
        controller.userData.index = i;
        controller.userData.velocity = new THREE.Vector3();
        controller.addEventListener("connected", (event) => {
          controller.userData.handedness = event.data.handedness;
          const url =
            controller.userData.handedness === "left"
              ? "https://raw.githubusercontent.com/immersive-web/webxr-input-profiles/main/packages/assets/profiles/generic-hand/left.glb"
              : "https://raw.githubusercontent.com/immersive-web/webxr-input-profiles/main/packages/assets/profiles/generic-hand/right.glb";
          gltfLoader.load(
            url,
            (gltf) => {
              const handWrapper = new THREE.Group();
              const handModel = gltf.scene;
              handModel.rotation.set(Math.PI / 2, 0, 0);
              handWrapper.add(handModel);
              controller.add(handWrapper);
            },
            undefined,
            (error) => {
              console.error("Error loading hand model:", error);
            }
          );
        });
        controller.addEventListener("squeezestart", onGrab);
        controller.addEventListener("squeezeend", onRelease);
        scene.add(controller);
        controllers.push(controller);
      }
      renderer.setAnimationLoop(animate);
    }

    // AR Button: Request an immersive-ar session and initialize game logic.
    document.getElementById("ar-button").addEventListener("click", async () => {
      try {
        const session = await navigator.xr.requestSession("immersive-ar", {
          requiredFeatures: ["local-floor", "hit-test", "plane-detection", "anchors"],
          optionalFeatures: ["mesh-detection"],
        });
        renderer.xr.setReferenceSpaceType("local-floor");
        renderer.xr.setSession(session);
        console.log("AR session started.");
        initGame();
      } catch (err) {
        console.error("Failed to start AR session:", err);
      }
    });
  </script>
</body>

</html>
