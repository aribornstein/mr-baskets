<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>WebXR Basketball with Rapier Physics</title>
    <style>
      body {
        margin: 0;
        overflow: hidden;
      }
      #score {
        position: absolute;
        top: 10px;
        left: 10px;
        font-size: 24px;
        color: white;
        z-index: 1;
      }
    </style>
  </head>
  <body>
    <div id="score">Score: 0</div>
    <script type="module">
      // Import Three.js and ARButton from CDN:
      import * as THREE from "https://cdn.jsdelivr.net/npm/three@0.146.0/build/three.module.js";
      import { ARButton } from "https://cdn.jsdelivr.net/npm/three@0.146.0/examples/jsm/webxr/ARButton.js";
      // Import the ES module build of Rapier:
      import * as RAPIER from "https://cdn.jsdelivr.net/npm/@dimforge/rapier3d-compat@0.14.0/rapier.es.js";

      // Global variables
      let scene, camera, renderer, controller, clock;
      let rapierWorld;
      let score = 0;
      const scoreEl = document.getElementById("score");

      // Three.js meshes
      let basketballMesh, hoopMesh, backboardMesh;
      const BALL_RADIUS = 0.12;
      const HOOP_RADIUS = 0.3;
      const hoopY = 1.8; // Hoop height

      // Rapier physics objects
      let ballRigidBody = null;
      let ballCollider = null;
      let hoopBody = null;
      let boardBody = null;

      // Initialize everything
      async function init() {
        // --- Initialize Rapier ---
        await RAPIER.init();
        // Create a physics world with gravity:
        rapierWorld = new RAPIER.World({ x: 0, y: -9.8, z: 0 });

        // --- Setup Three.js Scene ---
        scene = new THREE.Scene();
        camera = new THREE.PerspectiveCamera(
          70,
          window.innerWidth / window.innerHeight,
          0.01,
          20
        );

        // IMPORTANT: Create the renderer and attach it globally.
        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.xr.enabled = true;
        document.body.appendChild(renderer.domElement);

        // Add the AR button:
        document.body.appendChild(
          ARButton.createButton(renderer, { requiredFeatures: ["local-floor"] })
        );

        // --- Lighting ---
        const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 0.6);
        scene.add(hemiLight);
        const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
        dirLight.position.set(0, 4, 2);
        scene.add(dirLight);

        // --- Create Ground (Physics & Visual) ---
        createGroundPhysics();
        createGroundVisual();

        // --- Create Basketball (Physics & Visual) ---
        createBallPhysics({ x: 0, y: BALL_RADIUS, z: -1 });
        createBallVisual({ x: 0, y: BALL_RADIUS, z: -1 });

        // --- Create Hoop & Backboard (Physics & Visual) ---
        createHoopPhysics({ x: 0, y: hoopY, z: -2 });
        createHoopVisual({ x: 0, y: hoopY, z: -2 });

        // --- Setup AR Controller (if you plan on using interactions) ---
        controller = renderer.xr.getController(0);
        scene.add(controller);

        // Setup clock and resize listener:
        clock = new THREE.Clock();
        window.addEventListener("resize", onWindowResize, false);

        // Start the render loop using Three.js's XR animation loop:
        renderer.setAnimationLoop(animate);
      }

      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      }

      // --- Ground Creation ---
      function createGroundPhysics() {
        const groundBodyDesc = RAPIER.RigidBodyDesc.fixed().setTranslation(0, 0, 0);
        const groundBody = rapierWorld.createRigidBody(groundBodyDesc);
        const groundColliderDesc = RAPIER.ColliderDesc.cuboid(5, 0.1, 5)
          .setRestitution(0.2)
          .setFriction(0.8);
        rapierWorld.createCollider(groundColliderDesc, groundBody);
      }

      function createGroundVisual() {
        const groundGeo = new THREE.CircleGeometry(5, 32);
        const groundMat = new THREE.MeshStandardMaterial({
          color: 0x333333,
          side: THREE.DoubleSide,
          transparent: true,
          opacity: 0.2,
        });
        const groundMesh = new THREE.Mesh(groundGeo, groundMat);
        groundMesh.rotation.x = -Math.PI / 2;
        scene.add(groundMesh);
      }

      // --- Basketball Creation ---
      function createBallPhysics(pos) {
        const bodyDesc = RAPIER.RigidBodyDesc.dynamic().setTranslation(pos.x, pos.y, pos.z);
        ballRigidBody = rapierWorld.createRigidBody(bodyDesc);
        const colliderDesc = RAPIER.ColliderDesc.ball(BALL_RADIUS)
          .setRestitution(0.7)
          .setFriction(0.7);
        ballCollider = rapierWorld.createCollider(colliderDesc, ballRigidBody);
      }

      function createBallVisual(pos) {
        const geometry = new THREE.SphereGeometry(BALL_RADIUS, 32, 32);
        const material = new THREE.MeshStandardMaterial({ color: 0xff8c00 });
        basketballMesh = new THREE.Mesh(geometry, material);
        basketballMesh.position.set(pos.x, pos.y, pos.z);
        basketballMesh.name = "basketball";
        scene.add(basketballMesh);
      }

      // --- Hoop & Backboard Creation ---
      function createHoopPhysics(pos) {
        // Create a fixed body for the hoop:
        const hoopBodyDesc = RAPIER.RigidBodyDesc.fixed().setTranslation(pos.x, pos.y, pos.z);
        hoopBody = rapierWorld.createRigidBody(hoopBodyDesc);

        // Create the hoop ring as a thin cylinder.
        const ringColliderDesc = RAPIER.ColliderDesc.cylinder(0.02, HOOP_RADIUS)
          .setRestitution(0.5)
          .setFriction(0.8);
        // Use Three.js to compute a quaternion from Euler angles:
        const euler = new THREE.Euler(Math.PI / 2, 0, 0); // Rotate 90Â° around X-axis.
        const threeQuat = new THREE.Quaternion().setFromEuler(euler);
        // Convert the THREE.Quaternion to a plain object:
        const rapierQuat = { x: threeQuat.x, y: threeQuat.y, z: threeQuat.z, w: threeQuat.w };
        ringColliderDesc.setRotation(rapierQuat);

        rapierWorld.createCollider(ringColliderDesc, hoopBody);

        // Create the backboard as a separate fixed body:
        const boardBodyDesc = RAPIER.RigidBodyDesc.fixed().setTranslation(pos.x, pos.y, pos.z - 0.05);
        boardBody = rapierWorld.createRigidBody(boardBodyDesc);
        const boardColliderDesc = RAPIER.ColliderDesc.cuboid(0.3, 0.2, 0.01)
          .setRestitution(0.3)
          .setFriction(0.8);
        rapierWorld.createCollider(boardColliderDesc, boardBody);
      }

      function createHoopVisual(pos) {
        // Hoop visual (a red torus)
        const hoopGeometry = new THREE.TorusGeometry(HOOP_RADIUS, 0.02, 16, 100);
        const hoopMaterial = new THREE.MeshStandardMaterial({ color: 0xff0000 });
        hoopMesh = new THREE.Mesh(hoopGeometry, hoopMaterial);
        hoopMesh.rotation.x = Math.PI / 2;
        hoopMesh.position.set(pos.x, pos.y, pos.z);
        hoopMesh.name = "hoop";
        scene.add(hoopMesh);

        // Backboard visual (a blue plane)
        const boardGeometry = new THREE.PlaneGeometry(0.6, 0.4);
        const boardMaterial = new THREE.MeshStandardMaterial({ color: 0x0000ff });
        backboardMesh = new THREE.Mesh(boardGeometry, boardMaterial);
        backboardMesh.position.set(pos.x, pos.y, pos.z - 0.05);
        scene.add(backboardMesh);
      }

      // --- Animation Loop ---
      function animate() {
        const delta = clock.getDelta();

        // Step the physics simulation:
        rapierWorld.step();

        // Update the basketball mesh to match its physics body:
        if (ballRigidBody) {
          const t = ballRigidBody.translation();
          basketballMesh.position.set(t.x, t.y, t.z);
          const r = ballRigidBody.rotation();
          basketballMesh.quaternion.set(r.x, r.y, r.z, r.w);

          // Simple scoring: if the ball falls below hoop height and is within the hoop's radius.
          if (basketballMesh.position.y < hoopY) {
            const hoopCenter = new THREE.Vector3(0, hoopY, -2);
            if (basketballMesh.position.distanceTo(hoopCenter) < HOOP_RADIUS) {
              score++;
              scoreEl.innerHTML = "Score: " + score;
              // Remove the current ball and create a new one:
              rapierWorld.removeRigidBody(ballRigidBody);
              scene.remove(basketballMesh);
              createBallPhysics({ x: 0, y: BALL_RADIUS, z: -1 });
              createBallVisual({ x: 0, y: BALL_RADIUS, z: -1 });
            }
          }
        }

        // Render the scene
        renderer.render(scene, camera);
      }

      // Start everything
      init();
    </script>
  </body>
</html>
